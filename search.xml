<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DB-router</title>
    <url>/2019/10/12/DB-router/</url>
    <content><![CDATA[<h2 id="DB-router"><a href="#DB-router" class="headerlink" title="DB-router"></a>DB-router</h2><blockquote>
<p>通过编写<strong>db-router</strong>可以灵性连接<strong>mysql</strong>主从复制等情况下的多数据库</p>
</blockquote>
<ul>
<li>假设你已经配置好了类似<strong>MYSQL</strong>主从复制的服务，如果没有可以参照<a href="https://lienze.tech/blog/mysql/c813917a.html" target="_blank" rel="noopener">这里</a></li>
</ul>
<h3 id="配置Django数据库连接"><a href="#配置Django数据库连接" class="headerlink" title="配置Django数据库连接"></a>配置Django数据库连接</h3><a id="more"></a>

<ul>
<li>settings.py</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &apos;default&apos;: &#123;</span><br><span class="line">        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,</span><br><span class="line">        &apos;HOST&apos;: &apos;192.168.1.101&apos;,</span><br><span class="line">        &apos;PORT&apos;: 3306,</span><br><span class="line">        &apos;USER&apos;: &apos;root&apos;,</span><br><span class="line">        &apos;PASSWORD&apos;: &apos;123456&apos;,</span><br><span class="line">        &apos;NAME&apos;: &apos;test1&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;slave&apos;: &#123;</span><br><span class="line">        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,</span><br><span class="line">        &apos;HOST&apos;: &apos;192.168.1.102&apos;,</span><br><span class="line">        &apos;PORT&apos;: 3306,</span><br><span class="line">        &apos;USER&apos;: &apos;root&apos;,</span><br><span class="line">        &apos;PASSWORD&apos;: &apos;123456&apos;,</span><br><span class="line">        &apos;NAME&apos;: &apos;test1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DATABASE_ROUTERS = [&apos;pro.utils.MasterSlaveDBRouter&apos;]</span><br></pre></td></tr></table></figure>

<ul>
<li>编写<strong>db-router</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MasterSlaveDBRouter:</span><br><span class="line">    &quot;&quot;&quot;数据库主从读写分离路由&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def db_for_read(self, model, **hints):</span><br><span class="line">        &quot;&quot;&quot;读数据库&quot;&quot;&quot;</span><br><span class="line">        return &quot;slave&quot;</span><br><span class="line"></span><br><span class="line">    def db_for_write(self, model, **hints):</span><br><span class="line">        &quot;&quot;&quot;写数据库&quot;&quot;&quot;</span><br><span class="line">        return &quot;default&quot;</span><br><span class="line"></span><br><span class="line">    def allow_relation(self, obj1, obj2, **hints):</span><br><span class="line">        &quot;&quot;&quot;是否运行关联操作&quot;&quot;&quot;</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<ul>
<li>如出现以下错误，修改主库binlog日志格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django.db.utils.InternalError: (1665, &apos;Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.&apos;)</span><br><span class="line">binlog_format=mixed</span><br></pre></td></tr></table></figure>

<h3 id="打开日志用以分析"><a href="#打开日志用以分析" class="headerlink" title="打开日志用以分析"></a>打开日志用以分析</h3><ul>
<li>可以通过配置<strong>mysql</strong>日志记录，用以查看主从在读写情况下的效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">general_log=1</span><br><span class="line">general_log_file=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>OS模块</title>
    <url>/2019/03/04/OS%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h3><blockquote>
<p>使用os模块时，不需要考虑平台差异，解释器会帮大家选择正确的系统支持<br>可以对进程和进程运行环境进行管理<br>该模块还可以处理大部分文件系统操作，比如<strong>删除</strong>，<strong>重命名</strong>文件，<strong>遍历目录树</strong>，以及<strong>管理文件</strong>访问权限。</p>
</blockquote>
<a id="more"></a>

<ul>
<li>os模块主要有以下几种 :<ul>
<li><strong>posix</strong> (类unix操作系统)</li>
<li><strong>nt</strong> (win)</li>
<li><strong>mac</strong> (旧版本的<strong>MacOs</strong>)</li>
<li><strong>dos</strong> (DOS)**</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>os</strong>和<strong>sys</strong>：</p>
<blockquote>
<p>os负责程序与<strong>操作系统</strong>的交互<br>sys负责程序与<strong>解释器</strong>的交互</p>
</blockquote>
<hr>
</li>
<li><p><strong>os.path</strong>和<strong>sys.path</strong>：</p>
<blockquote>
<p>sys.path是<strong>PATH</strong>环境变量<br>os.path是os模块下的子模块，提供了一些关于路径处理的函数</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="os模块常用函数"><a href="#os模块常用函数" class="headerlink" title="os模块常用函数"></a>os模块常用函数</h4><ul>
<li>os.name：输出字符串指示正在使用的平台</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.name</span><br><span class="line">&apos;nt&apos;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>os.getcwd()：得到当前<strong>工作目录</strong>(就是你的进程所工作的目录)，即当前脚本工作路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.getcwd()</span><br><span class="line">&apos;C:\\Users\\Administrator&apos;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>运行目录</strong>：执行程序时的路径</li>
<li><strong>工作目录</strong>：程序运行时，程序中我们要操作其他文件时使用的的一系列相对路径(相对路径需要参照)，工作目录可在程序运行时更改</li>
</ul>
</blockquote>
<hr>
<ul>
<li>os.listdir()：返回指定目录下的所有文件和目录名的一个列表，但是并没有列出来什么是目录，什么是文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.listdir()</span><br><span class="line">&gt;&gt;&gt; os.listdir()</span><br><span class="line">[ &apos;桌面&apos;, &apos;下载&apos;, &apos;模板&apos;, &apos;公共&apos;, &apos;文档&apos;, &apos;音乐&apos;, &apos;图片&apos;, &apos;视频&apos;]</span><br><span class="line">#结果为列表，但是并没有列出谁是目录，谁是文件</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>os.remove(‘file_name’)：<strong>删除</strong>指定<strong>文件</strong>，文件不存在则报错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.remove(&apos;1.txt&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &apos;1.txt&apos;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>os.rmdir(‘dir_name’)：<strong>删除</strong>指定<strong>目录</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.remove(&apos;桌面&apos;)</span><br><span class="line">#删除桌面目录</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>os.mkdir(‘dir_name’)：<strong>创建</strong>目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.mkdir(&apos;桌面&apos;)</span><br><span class="line">#创建目录名为桌面</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>os.makedirs(‘a/b/c’)：<strong>递归创建</strong>目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.makedirs(&apos;a/b/c&apos;)</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>os.system(‘ls’)：执行<strong>shell</strong>命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.system(&apos;su rm -rf /*&apos;)</span><br><span class="line">#四大皆空</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>os.chdir(‘file_path’)：改变<strong>工作目录</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.getcwd()</span><br><span class="line">&apos;C:\\Users\\Administrator&apos;</span><br><span class="line">&gt;&gt;&gt; os.chdir(&apos;C:\\Users&apos;)</span><br><span class="line">&gt;&gt;&gt; os.getcwd()</span><br><span class="line">&apos;C:\\Users&apos;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>os.chmod(‘file_name’)：改变文件或目录的<strong>权限</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.chmod(&apos;1.txt&apos;,445)</span><br><span class="line">&gt;&gt;&gt; os.system(&apos;ls -l 1.txt&apos;)</span><br><span class="line">-rw-rwxr-x 1 root root 0 1月  19 11:42 1.txt</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Os-path模块常用函数"><a href="#Os-path模块常用函数" class="headerlink" title="Os.path模块常用函数"></a>Os.path模块常用函数</h3><ul>
<li><p>os.path.abspath(‘file_name’)</p>
<p>：</p>
<ul>
<li>返回文件或目录的绝对路径</li>
<li>不会检查是否存在该文件或目录</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;1.txt&apos;)</span><br><span class="line">&apos;/root/1.txt&apos;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>os.path.split(‘file_path’)</p>
<p>：</p>
<ul>
<li>将路径分隔成目录和文件名，并以一个元组返回</li>
<li>不会检查是否存在该文件或目录</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.split(&apos;/root/1.txt&apos;)</span><br><span class="line">(&apos;/root&apos;, &apos;1.txt&apos;)</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>os.path.basename(‘path’)</p>
<p>：</p>
<ul>
<li>返回路径最后的文件名</li>
<li>如果后面还有\ / 那么返回一个空字符串</li>
<li>不会检查是否存在该文件或目录</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.basename(&apos;/root/1.txt&apos;)</span><br><span class="line">&apos;1.txt&apos;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>os.path.exists(‘file_path’)</p>
<p>：</p>
<ul>
<li>如果路径存在，则返回True，反之返回False</li>
<li>与上面的函数不同，他就是检查这个路径是否存在</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.exists(&apos;/root/2.txt&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>os.path.join(‘file_path’，’file_name’)</p>
<p>：</p>
<ul>
<li>路径拼接</li>
<li>不会检查是否存在该文件或目录</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.join(&apos;/root&apos;,&apos;abc&apos;)</span><br><span class="line">&apos;/root/abc&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;root&apos;,&apos;abc&apos;)</span><br><span class="line">&apos;root/abc&apos;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>os.path.isdir(‘name’)</p>
<p>：</p>
<ul>
<li>判断是否为目录，返回值为bool</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.isdir(&apos;/root&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; os.path.isdir(&apos;1.txt&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>os.path.isfile(‘name’)</p>
<p>：</p>
<ul>
<li>判断是否为文件，返回值为bool</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.isfile(&apos;/root&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; os.path.isfile(&apos;1.txt&apos;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>os.path.islink(‘name’)</p>
<p>：</p>
<ul>
<li>判断是否是链接，返回值为bool</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.islink(&apos;1.txt&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; os.path.islink(&apos;/usr/bin/python3&apos;)</span><br><span class="line">True</span><br><span class="line">#ln -s 是我们在linux下创建连接的命令，类似win下的快捷方式</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>os.path.getsize(‘path’)</p>
<p>：</p>
<ul>
<li>返回文件大小</li>
<li>如果文件不存在，抛出异常</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.getsize(&apos;1.txt&apos;)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; os.path.getsize(&apos;2.txt&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;/usr/local/python3/lib/python3.6/genericpath.py&quot;, line 50, in getsize</span><br><span class="line">    return os.stat(filename).st_size</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &apos;2.txt&apos;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础操作</title>
    <url>/2018/12/12/Linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><blockquote>
<p>随着IT产业的不断发展，<code>Linux</code>操作系统应用领域越来越广泛，尤其是近年来<code>Linux</code>在服务器领域飞速的发展，主要得益于<code>Linux</code>操作系统具备的如下优点</p>
</blockquote>
<ul>
<li>开源免费</li>
<li>系统迭代更新</li>
<li>系统性能稳定</li>
<li>安全性高</li>
<li>多任务、多用户</li>
<li>耗资源小、无需图形化界面</li>
<li>内核小</li>
<li>应用领域广泛</li>
<li>使用及入门容易</li>
</ul>
<a id="more"></a>



<h3 id="操作系统分类简介"><a href="#操作系统分类简介" class="headerlink" title="操作系统分类简介"></a>操作系统分类简介</h3><blockquote>
<p>学习<code>Linux</code>操作系统，需要选择不同的发行版本</p>
<p><code>Linux</code>操作系统是一个大类别，<code>Linux</code>操作系统主流发行版本包括：<code>Red Hat Linux</code>、<code>CentOS</code>、<code>Ubuntu</code>、<code>SUSE Linux</code>、<code>Fedora Linux</code>等，具体发行版本区别如下</p>
</blockquote>
<ul>
<li><code>Red Hat Linux</code></li>
</ul>
<blockquote>
<p><code>Red Hat Linux</code>是最早的<code>Linux</code>发行版本之一</p>
<p>同时也是最著名的<code>Linux</code>版本，<code>Red Hat Linux</code>已经创造了自己的品牌，也是读者经常听到的“红帽操作系统”</p>
<p><code>Red Hat 1994</code>年创立，目前公司全世界有<code>3000</code>多人，一直致力于开放的源代码体系，向用户提供一套完整的服务，这使得它特别适合在公共网络中使用</p>
<p>这个版本的<code>Linux</code>也使用最新的内核，还拥有大多数人都需要使用的主体软件包</p>
</blockquote>
<ul>
<li><code>CentOS</code></li>
</ul>
<blockquote>
<p>社区企业版操作系统（<code>Community Enterprise Operating System</code>，<code>CentOS</code>）是<code>Linux</code>发行版之一，它是来自于<code>Red Hat Enterprise Linux</code>依照开放源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以<code>CentOS</code>替代商业版的<code>Red Hat Enterprise Linux</code>使用。</p>
<p><code>CentOS</code>于<code>Red Hat Linux</code>不同之处在于<code>CentOS</code>并不包含封闭的源代码软件，可以开源免费使用，得到运维人员、企业、程序员的青睐，<code>CentOS</code>发行版操作系统是目前企业使用最多的系统之一</p>
<p><code>2016年12月12日</code>，<code>CentOS</code>基于<code>Red Hat Enterprise Linux的CentOS Linux 7 (1611)</code>系统正式对外发布</p>
</blockquote>
<ul>
<li><code>Ubuntu</code></li>
</ul>
<blockquote>
<p><code>Ubuntu</code>是一个以桌面应用为主的<code>Linux</code>操作系统，其名称来自非洲南部祖鲁语或豪萨语的“<code>ubuntu</code>”一词（译为吾帮托或乌班图），意思是“人性”、“我的存在是因为大家的存在”，是非洲传统的一种价值观</p>
<p><code>Ubuntu</code>基于<code>Debian</code>发行版和<code>GNOME</code>桌面环境，<code>Ubuntu</code>发行版操作系统的目标在于为一般用户提供一个最新的、同时稳定的以开放自由软件构建而成的操作系统，目前<code>Ubuntu</code>具有庞大的社区力量，用户可以方便地从社区获得帮助</p>
</blockquote>
<ul>
<li><code>SUSE Linux</code></li>
</ul>
<blockquote>
<p><code>SUSE</code>(发音 /ˈsuːsə/)，<code>SUSE Linux</code>出自德国，<code>SuSE Linux AG</code>公司发行维护的<code>Linux</code>发行版，是属于此公司的注册商标<code>2003年11月4日</code>，<code>Novell</code>表示将会对<code>SUSE</code>提出收购。收购的工作于<code>2004年1月</code>完成。</p>
<p><code>Novell</code>也向大家保证<code>SUSE</code>的开发工作仍会继续下去，<code>Novell</code>更把公司内全线电脑的系统换成<code>SUSE LINUX</code>，并同时表示将会把<code>SUSE</code>特有而优秀的系统管理程序 - <code>YaST2</code>以<code>GPL</code>授权释出</p>
</blockquote>
<ul>
<li><code>Fedora Linux</code></li>
</ul>
<blockquote>
<p><code>Fedora</code>是一个知名的<code>Linux</code>发行版，是一款由全球社区爱好者构建的面向日常应用的快速、稳定、强大的操作系统。</p>
<p>它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发。</p>
<p>这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。<code>Fedora</code>约每六个月会发布新版本</p>
</blockquote>
<h3 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h3><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a><code>cd</code></h4><blockquote>
<p>目录切换</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd .. # 上一层目录</span><br><span class="line">cd # 家目录</span><br><span class="line">cd ~ # 家目录</span><br><span class="line">cd / # 根目录</span><br></pre></td></tr></table></figure>

<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a><code>ls</code></h4><blockquote>
<p>浏览目录下的文件或文件夹</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -a # 列举所有文件或目录，包含.开头的隐藏文件</span><br><span class="line">ls -l # 详细信息列举文件或目录</span><br><span class="line">ls -i # 列出每个文件的Inode号</span><br><span class="line">ls -t # 根据修改时间列出文件</span><br></pre></td></tr></table></figure>

<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a><code>pwd</code></h4><blockquote>
<p>显示当前所处目录</p>
</blockquote>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><code>mkdir</code></h4><blockquote>
<p>创建目录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir a # 创建a目录</span><br><span class="line">mkdir -p a/b/c # 递归创建目录</span><br></pre></td></tr></table></figure>

<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h4><blockquote>
<p>删除文件或目录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm a # 删除a文件</span><br><span class="line">rm -r a # 删除a目录</span><br><span class="line">rm -rf a # 强制删除a文件，不提示确认</span><br></pre></td></tr></table></figure>

<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h4><blockquote>
<p>拷贝或备份文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp /root/1.py /home/1.py # 拷贝文件至新目录下</span><br></pre></td></tr></table></figure>

<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a><code>mv</code></h4><blockquote>
<p>重命名或移动文件或目录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv /root/1.py /home/1.py.bak # 移动文件并重新命名</span><br></pre></td></tr></table></figure>

<h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a><code>touch</code></h4><blockquote>
<p>创建普通文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch 1.py # 创建1.py文件</span><br></pre></td></tr></table></figure>

<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a><code>cat</code></h4><blockquote>
<p>查看文件内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/redis/redis.conf # 查看redis.conf文件</span><br><span class="line">cat -n # 对输出所有行进行编号</span><br><span class="line">cat -b # 对输出非空行进行编号</span><br></pre></td></tr></table></figure>

<h4 id="head"><a href="#head" class="headerlink" title="head"></a><code>head</code></h4><blockquote>
<p>查看文件头部内容，通常为十行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head -3 /etc/memcached.conf # 查看前三行</span><br><span class="line">head -n 100 # 查看前100行</span><br><span class="line">head -c 3 # 查看前三字节</span><br></pre></td></tr></table></figure>

<h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a><code>tail</code></h4><blockquote>
<p>查看文件头部内容，通常为十行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -n 3 1.txt # 查看后3行</span><br><span class="line">tail -f # 阻塞并即使输出文件变化后追加的数据</span><br></pre></td></tr></table></figure>

<h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a><code>chmod</code></h4><blockquote>
<p>修改文件或目录权限</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 775 1.py # 赋予文件775权限 rwx rwx r-x</span><br></pre></td></tr></table></figure>

<h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a><code>chown</code></h4><blockquote>
<p>修改文件或目录所属组及所属用户</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown –R root.root /tmp/test.txt # 文件所属用户及所属组均为root</span><br></pre></td></tr></table></figure>

<h4 id="df"><a href="#df" class="headerlink" title="df"></a><code>df</code></h4><blockquote>
<p>磁盘信息查询</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h # 查询磁盘使用量</span><br><span class="line">df -i # 分区Inode使用量</span><br></pre></td></tr></table></figure>

<h4 id="du"><a href="#du" class="headerlink" title="du"></a><code>du</code></h4><blockquote>
<p>查看文件大小</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -h 1.txt # 查看1.txt文件大小</span><br></pre></td></tr></table></figure>

<h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a><code>echo</code></h4><blockquote>
<p>打印或输出内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &apos;hello&apos; # 输出hello</span><br><span class="line">echo &apos;hello&apos; &gt; 1.md # 以hello内容覆盖1.md</span><br><span class="line">echo &apos;hello&apos; &gt;&gt; 1.md # 以hello追加至1.md文件中</span><br></pre></td></tr></table></figure>

<h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a><code>tar</code></h4><blockquote>
<p>解压或压缩文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -jxvf # 解压bz2属性的压缩包</span><br><span class="line">tar -zxvf # 解压gz属性的压缩包</span><br><span class="line">tar -czvf # 使用gzip格式压缩文件</span><br><span class="line">tar -cjvf # 使用bzip2格式压缩文件</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 发布者与订阅者,键空间事件</title>
    <url>/2018/10/16/Redis%E5%8F%91%E5%B8%83%E8%80%85%E4%B8%8E%E8%AE%A2%E9%98%85%E8%80%85%EF%BC%8C%E9%94%AE%E7%A9%BA%E9%97%B4%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="发布者与订阅者（pub-sub）"><a href="#发布者与订阅者（pub-sub）" class="headerlink" title="发布者与订阅者（pub/sub）"></a>发布者与订阅者（pub/sub）</h2><p>发布和订阅<code>pub/sub</code>，订阅者负责订阅频道，发送者负责像频道发送二进制字符串消息，每当有消息发布到订阅的这个频道，那么所有的订阅者都可以收到这个消息，发布订阅也是像是我们生活中的电台，订阅者可以订阅收听多个电台，而发送者可以再任何电台发送消息</p><a id="more"></a>
<h3 id="发布，订阅常用命令"><a href="#发布，订阅常用命令" class="headerlink" title="发布，订阅常用命令"></a>发布，订阅常用命令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>SUBSCRIBE CHANNLE</td>
<td>订阅给定的一个或多个频道</td>
</tr>
<tr>
<td>UNSUBSCRIBE CHANNLE</td>
<td>退订一个或多个频道，如果没有指定具体退订的频道，那么是全部退订</td>
</tr>
<tr>
<td>PSUBSCRIBE PATTERN</td>
<td>订阅与给定模式相匹配的所有频道</td>
</tr>
<tr>
<td>PUNSUBSCRIBE PATTERN</td>
<td>退订给定的模式相匹配的频道，未指定，则退订所有</td>
</tr>
<tr>
<td>PUBLISH CHANNLE MESSAGE</td>
<td>向给定频道发送消息</td>
</tr>
</tbody></table>
<h2 id="键空间事件"><a href="#键空间事件" class="headerlink" title="键空间事件"></a>键空间事件</h2><h3 id="键空间事件通知"><a href="#键空间事件通知" class="headerlink" title="键空间事件通知"></a>键空间事件通知</h3><p>在<code>Redis</code>里面有一些事件，比如键<strong>到期</strong>、键被<strong>删除</strong>等。可以通过打开<code>redis</code>键空间事件通知来让 Redis 一旦触发这些事件的时候就往特定的<code>Channel</code>推一条消息</p>
<h3 id="键事件通知配置"><a href="#键事件通知配置" class="headerlink" title="键事件通知配置"></a>键事件通知配置</h3><ul>
<li>默认在<code>redis</code>中，键事件通知是不打开的，需要我们手动配置，具体的选项如下，默认他是个空字符串，代表关闭状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">notify-keyspace-events &quot;&quot;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>K</td>
<td>键空间通知，所有通知以<code>__keyspace@&lt;db&gt;__</code> 为前缀</td>
</tr>
<tr>
<td>E</td>
<td>键事件通知，所有通知以<code>__keyevent@&lt;db&gt;__</code> 为前缀</td>
</tr>
<tr>
<td>g</td>
<td><code>DEL</code>、<code>EXPIRE</code>、<code>RENAME</code>等类型无关的通用命令的通知</td>
</tr>
<tr>
<td>$</td>
<td>字符串命令的通知</td>
</tr>
<tr>
<td>l</td>
<td>列表命令的通知</td>
</tr>
<tr>
<td>s</td>
<td>集合命令的通知</td>
</tr>
<tr>
<td>h</td>
<td>哈希命令的通知</td>
</tr>
<tr>
<td>z</td>
<td>有序集合命令的通知</td>
</tr>
<tr>
<td>x</td>
<td>过期事件：每当有过期键被删除时发送</td>
</tr>
<tr>
<td>e</td>
<td>驱逐<code>(evict)</code>事件：每当有键因为<code>maxmemory</code>政策而被删除时发送</td>
</tr>
<tr>
<td>A</td>
<td>参数<code>g$lshzxe</code>的别名</td>
</tr>
</tbody></table>
<p>注意，该选项的值中至少需要包含K或者E，否则不会发布任何事件。比如，如果需要开启针对列表的keyspace事件通知，则该选项需要配置为“Kl”； </p>
<h3 id="键空间和键事件"><a href="#键空间和键事件" class="headerlink" title="键空间和键事件"></a>键空间和键事件</h3><blockquote>
<p>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件</p>
<p>比如说，对<code>0</code>号数据库的键<code>mykey</code>执行<code>DEL</code>命令时， 系统将分发两条消息， 相当于执行以下两个<code>PUBLISH</code>命令</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__keyspace@0__:mykey</code>：接收<code>0</code>号数据库中所有修改键<code>mykey</code>的事件</li>
<li><code>__keyevent@0__:del</code>：接收<code>0</code>号数据库中所有执行<code>del</code>命令的键</li>
</ul>
<blockquote>
<p><code>keyspace</code>为前缀的频道被称为键空间通知<code>key-space notification</code></p>
</blockquote>
<blockquote>
<p><code>keyevent</code>为前缀的频道则被称为键事件通知<code>key-event notification</code></p>
</blockquote>
<ul>
<li>订阅<strong>键空间频道</strong>，监控被执行事件的键，如监控<code>mykey</code>；那么此时将接收到该键所对应的事件：<code>del</code></li>
<li>订阅<strong>键事件频道</strong>，监控某个事件，如<code>del</code>；那么<code>del</code>事件触发时，订阅者收到：<code>mykey</code></li>
</ul>
<h3 id="过期的键事件通知"><a href="#过期的键事件通知" class="headerlink" title="过期的键事件通知"></a>过期的键事件通知</h3><ul>
<li>过期的键事件通知常用在订单过期通知等场景下，此时只需要订阅对应<strong>过期事件</strong>的频道，当某键触发过期事件时，即可接受到对应<strong>过期键</strong>的消息</li>
<li><code>redis</code>配置如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">notify-keyspace-events &quot;Ex&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Python</code>代码的简单示范，订阅过期频道</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import redis</span><br><span class="line">import time</span><br><span class="line">redis = redis.Redis(host=&apos;123.57.61.168&apos;, port=6379)</span><br><span class="line">pubsub = redis.pubsub()</span><br><span class="line">pubsub.psubscribe(&apos;__keyevent@0__:expired&apos;) # 订阅过期事件频道</span><br><span class="line">print(&apos;Starting message loop&apos;)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        message = pubsub.get_message()</span><br><span class="line">        if message:</span><br><span class="line">            print(message)</span><br><span class="line">        else:</span><br><span class="line">            time.sleep(0.01)</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        # CTRL + C</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<ul>
<li>那么当此时执行此段代码，另起<code>redis</code>客户端，设置一个可以过期的<code>key</code>值，来看一下效果</li>
</ul>
<p><img src="/2018/10/16/Redis发布者与订阅者，键空间事件/%E9%94%AE%E8%BF%87%E6%9C%9F%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5.gif" alt="键过期事件通知"></p>
<h3 id="不同命令产生的事件通知"><a href="#不同命令产生的事件通知" class="headerlink" title="不同命令产生的事件通知"></a>不同命令产生的事件通知</h3><ul>
<li>DEL 命令为每个被删除的键产生一个 del 事件；</li>
<li>RENAME 产生两个事件：为源键产生一个 rename_from 事件，并为目标键产生一个 rename_to 事件；</li>
<li>EXPIRE命令，在设置键的过期时间时产生一个 expire事件；当键因过期而被删除时，产生一个 expired事件；</li>
<li>SORT命令，在带有 STORE 参数时产生一个 sortstore事件。如果 STORE 指示的用于保存排序结果的键已经存在，则原键会被删除，因此还会产生一个 del 事件；</li>
<li>SET 以及它的所有变种(SETEX、SETNX和GETSET)都产生set事件。另外，SETEX命令还会产生expire 事件；</li>
<li>MSET 命令，为每个键产生一个 set 事件；</li>
<li>SETRANGE 产生一个 setrange 事件；</li>
<li>INCR 、DECR、INCRBY和DECRBY都产生 incrby 事件；</li>
<li>INCRBYFLOAT产生incrbyfloat事件；</li>
<li>APPEND产生append事件；</li>
<li>LPUSH和LPUSHX都产生单个 lpush 事件，即使有多个输入元素时，也是如此；</li>
<li>RPUSH 和 RPUSHX 都产生单个rpush事件，即使有多个输入元素时，也是如此；</li>
<li>RPOP 产生 rpop 事件，如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 事件；</li>
<li>LPOP 产生 lpop 事件，如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 事件；</li>
<li>LINSERT 产生一个 linsert 事件；</li>
<li>LSET 产生一个 lset 事件；</li>
<li>LREM产生一个lrem事件，如果该命令执行之后，列表键被清空，则还会产生一个 del 事件；</li>
<li>LTRIM 产生一个ltrim事件，如果该命令执行之后，列表键被清空，则还会产生一个 del 事件；</li>
<li>RPOPLPUSH 和 BRPOPLPUSH 产生一个 rpop 事件，以及一个 lpush 事件。两个命令都保证rpop事件在 lpush 事件之前发出。如果弹出元素之后，列表键被清空，则还会产生一个 del 事件；</li>
<li>HSET 、 HSETNX 和 HMSET 都只产生一个 hset 事件；</li>
<li>HINCRBY 产生一个 hincrby 事件；</li>
<li>HINCRBYFLOAT 产生一个 hincrbyfloat 事件；</li>
<li>HDEL 产生一个 hdel 通知。如果执行该命令之后，哈希键被清空，则还会产生一个del事件；</li>
<li>SADD 产生一个 sadd 事件，即使有多个输入元素时，也是如此；</li>
<li>SREM 产生一个 srem 事件，如果执行该命令之后，集合键被清空，则还会产生一个 del 事件；</li>
<li>SMOVE 为源键产生一个 srem 事件，并为目标键产生一个sadd 事件；</li>
<li>SPOP 产生一个 spop 事件。如果执行该命令之后，集合键被清空，则还会产生一个 del 事件；</li>
<li>SINTERSTORE、SUNIONSTORE和SDIFFSTORE分别产生 sinterstore、sunionostore和sdiffstore 三种事件。如果用于保存结果的键已经存在，则还会产生一个 del 事件；</li>
<li>ZINCR产生一个 zincr 事件；</li>
<li>ZADD 产生一个 zadd事件，即使有多个输入元素时，也是如此；</li>
<li>ZREM 产生一个 zrem 通知，即使有多个输入元素时，也是如此。如果执行 ZREM 之后，有序集合键被清空，则还会产生一个 del 事件；</li>
<li>ZREMEBYSCORE 产生一个 zrembyscore事件，如果用于保存结果的键已经存在，则还会产生一个 del 事件。</li>
<li>ZREMBYRANK 产生一个 zrembyrank事件，如果用于保存结果的键已经存在，则还会产生一个 del 事件。</li>
<li>ZINTERSTORE 和 ZUNIONSTORE 分别产生 zinterstore 和 zunionstore 两种事件。如果用于保存结果的键已经存在，那么还会产生一个 del 事件。</li>
<li>每当一个键因为过期而被删除时，产生一个 expired 事件。</li>
<li>每当一个键因为 maxmemory策略而被删除并回收内存时，产生一个 evicted 事件。</li>
</ul>
<p>注意：所有命令都只在键真的被改动了之后，才会产生事件通知。比如，当srem命令试图删除不存在于集合的元素时，删除操作执行失败，因为没有真正的改动键，所以这一操作不会发送通知。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>1：Redis发布所有通知，客户端A订阅所有消息：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set notify-keyspace-events KEA</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; psubscribe key*@0:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;key*@0:*&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>

<p>然后，在客户端B上执行set和del命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set msg &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; del msg</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; del msg</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>然后客户端A的打印如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;key*@0:&quot;</span><br><span class="line">3) &quot;keyspace@0:msg&quot;</span><br><span class="line">4) &quot;set&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;__key@0:*&quot;</span><br><span class="line">3) &quot;keyevent@0__:set&quot;</span><br><span class="line">4) &quot;msg&quot;</span><br><span class="line"></span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;key*@0:&quot;</span><br><span class="line">3) &quot;keyspace@0:msg&quot;</span><br><span class="line">4) &quot;del&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;__key@0:*&quot;</span><br><span class="line">3) &quot;keyevent@0__:del&quot;</span><br><span class="line">4) &quot;msg&quot;</span><br></pre></td></tr></table></figure>

<p> 可见，针对每一个操作，客户端A都收到了两种消息，分别是keyspace和keyevent消息。</p>
<p><strong>2：使Redis仅发布keyspace通知，而客户端A订阅所有消息类型：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set notify-keyspace-events KA</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; psubscribe key*@0:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;key*@0:*&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>

<p>在客户端B上执行，与上面同样的步骤。此时，客户端A上的打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;key*@0:*&quot;</span><br><span class="line">3) &quot;keyspace@0:msg&quot;</span><br><span class="line">4) &quot;set&quot;</span><br><span class="line"></span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;key*@0:*&quot;</span><br><span class="line">3) &quot;keyspace@0:msg&quot;</span><br><span class="line">4) &quot;del&quot;</span><br></pre></td></tr></table></figure>

<p>可见，尽管客户端A订阅了所有消息，但是Redis仅发布了keyspace事件。而且，在客户端B上执行了两次del操作，而只有第一个del成功执行了，从而产生了一个事件。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis 发布者与订阅者,键空间事件</tag>
      </tags>
  </entry>
  <entry>
    <title>HayStack全文检索在Django中的应用</title>
    <url>/2018/10/16/HayStack%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%9C%A8Django%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><p><a href="https://django-haystack.readthedocs.io/en/v2.4.1/tutorial.html" target="_blank" rel="noopener">官方文档</a></p>
<blockquote>
<p>全文检索就是针对所有内容进行动态匹配搜索的概念</p>
<p>针对特定的关键词进行<strong>建立索引</strong>并<strong>精确匹配</strong>取出搜索结果，并且达到性能优化的目的</p>
</blockquote>
<a id="more"></a>

<ul>
<li>为啥要有全文检索</li>
</ul>
<blockquote>
<p>最常见的全文检索就是我们在数据库中进行的模糊查询</p>
<p>但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低</p>
<p>常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作</p>
<p>如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项</p>
</blockquote>
<ul>
<li><code>django</code>使用啥进行全文检索</li>
</ul>
<blockquote>
<p><code>Python</code>提供了各种模块进行全文检索，最常见的是<code>haystack</code>模块</p>
<p>该模块设计为支持<code>whoosh</code>、<code>solr</code>、<code>Xapian</code>、<code>Elasticsearch</code>四种全文检索引擎后端</p>
<p>使用<code>haystack</code>模块，不用更改代码，直接切换引擎，可以极大的减少代码量</p>
<p><code>haystack</code>属于一种<strong>全文检索</strong>的框架</p>
</blockquote>
<hr>
<ul>
<li><strong>whoosh</strong></li>
</ul>
<blockquote>
<p>纯<code>Python</code>编写的全文搜索引擎，是目前最快的<code>python</code>所编写的检索引擎，虽然性能比不上<code>solr</code>、<code>Xapian</code>、<code>Elasticsearch</code>等；但是无二进制包，程序不会莫名其妙的崩溃，对于小型的站点，<code>whoosh</code>已经足够使用</p>
</blockquote>
<ul>
<li><strong>solr</strong></li>
</ul>
<blockquote>
<p><code>Solr</code>是一个高性能，采用<code>Java5</code>开发，基于<code>Lucene</code>的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎</p>
<p><code>Lucene</code>：不是一个完整的<strong>全文检索引擎</strong>，是一个全文检索引擎的<strong>架构</strong>，提供了完整的查询引擎和索引引擎，<code>Lucene</code>的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能</p>
</blockquote>
<ul>
<li><strong>Xapian</strong></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Xapian`是一个用`C++`编写的全文检索程序，他的作用类似于`Java`的`lucene</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>Elasticsearch</strong></li>
</ul>
<blockquote>
<p><code>ElasticSearch</code>是一个基于<code>Lucene</code>的搜索服务器它提供了一个分布式多用户能力的全文搜索引擎，基于<code>RESTful web</code>接口</p>
<p><code>Elasticsearch</code>是用Java开发的，并作为<code>Apache</code>许可条款下的开放源码发布，是当前流行的企业级搜索引擎。该引擎常设计用于云计算中；能够达到<strong>实时搜索</strong>，<strong>稳定</strong>，<strong>可靠</strong>，<strong>快速</strong>，<strong>安装</strong>使用方便</p>
</blockquote>
<h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><blockquote>
<p><code>whoosh</code>作为一个全文搜索引擎模块</p>
<p>分词功能和检索功能已经非常强大，但是针对中文的处理还是比较欠缺</p>
<p>可以通过<code>Jieba</code>模块重写分词操作，支持<code>whoosh</code>对中文的强大操作</p>
</blockquote>
<ul>
<li>安装中文分词模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install jieba</span><br></pre></td></tr></table></figure>

<ul>
<li><p>除了<code>jieba</code>分词，现在还有很多付费的中文分词模块</p>
<blockquote>
<p><a href="http://ictclas.nlpir.org/nlpir/" target="_blank" rel="noopener">中科院计算所NLPIR</a></p>
<p><a href="https://github.com/NLPchina/ansj_seg" target="_blank" rel="noopener"><code>ansj</code>分词器</a></p>
<p><a href="https://github.com/HIT-SCIR/ltp" target="_blank" rel="noopener">哈工大的<code>LTP</code></a></p>
<p><a href="https://github.com/thunlp/THULAC" target="_blank" rel="noopener">清华大学<code>THULAC</code></a></p>
<p><a href="https://nlp.stanford.edu/software/segmenter.shtml" target="_blank" rel="noopener">斯坦福分词器</a></p>
<p><a href="https://github.com/hankcs/HanLP" target="_blank" rel="noopener"><code>Hanlp</code>分词器</a></p>
<p><a href="https://github.com/yanyiwu/cppjieba" target="_blank" rel="noopener">结巴分词</a></p>
<p><a href="https://github.com/koth/kcws" target="_blank" rel="noopener"><code>KCWS</code>分词器(字嵌入<code>+Bi-LSTM+CRF</code>)</a></p>
<p><a href="https://github.com/frcchang/zpar/releases" target="_blank" rel="noopener"><code>ZPar</code></a></p>
<p><a href="https://github.com/wks/ik-analyzer" target="_blank" rel="noopener"><code>IKAnalyzer</code></a></p>
</blockquote>
</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>首先安装<code>HayStack</code>框架以及<code>whoosh</code>搜索引擎</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django-haystack</span><br><span class="line">pip install whoosh</span><br></pre></td></tr></table></figure>

<h3 id="settings配置"><a href="#settings配置" class="headerlink" title="settings配置"></a>settings配置</h3><ul>
<li>添加<code>haystack</code>应用到项目的<code>settings</code>文件下的<code>app</code>部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &apos;django.contrib.admin&apos;,</span><br><span class="line">	...</span><br><span class="line">    &apos;haystack&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>添加搜索引擎，这里使用<code>whoosh</code>引擎</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HAYSTACK_CONNECTIONS = &#123;</span><br><span class="line">    &apos;default&apos;: &#123;</span><br><span class="line">        &apos;ENGINE&apos;: &apos;haystack.backends.whoosh_cn_backend.WhooshEngine&apos;,</span><br><span class="line">        &apos;PATH&apos;: os.path.join(BASE_DIR, &apos;whoosh_index&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#这里使用django的信号机制，在数据表发生改动时自动更新whoosh的查询索引</span><br><span class="line">HAYSTACK_SIGNAL_PROCESSOR = &apos;haystack.signals.RealtimeSignalProcessor&apos;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里要注意的是，我们使用的引擎为<code>whoosh_cn_backend</code></p>
<p>本身的<code>whoosh</code>引擎名为：<code>whoosh_backend</code></p>
<p><code>whoosh_cn_backend</code>将在接下来我们对安装目录下的引擎文件复制修改得来</p>
</blockquote>
<ul>
<li>在项目的路由文件下配置查询的路由映射</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.urls import include,re_path</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;admin/&apos;, admin.site.urls),</span><br><span class="line">    re_path(&apos;^search/&apos;,include(&apos;haystack.urls&apos;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当查询条件被提交时，会跳转至<code>search</code>路由</p>
<p>并且查询条件会作为<code>get</code>请求时的连接参数传入，参数<code>key</code>值为<code>q</code></p>
</blockquote>
<h3 id="创建索引文件"><a href="#创建索引文件" class="headerlink" title="创建索引文件"></a>创建索引文件</h3><ul>
<li>接下来，在需要被搜索的<code>app</code>下建立<code>search_indexes.py</code>文件，该文件名不许变更</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#app.models.py</span><br><span class="line">class User(models.Model):</span><br><span class="line">    # 用户表</span><br><span class="line">    name = models.CharField(</span><br><span class="line">        max_length=50,</span><br><span class="line">        verbose_name=&apos;昵称&apos;</span><br><span class="line">        )</span><br><span class="line">    account = models.CharField(max_length=50,verbose_name=&apos;账号&apos;,unique=True)</span><br><span class="line">    passwd = models.CharField(max_length=50,verbose_name=&apos;密码&apos;)</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line">#app.search_indexes.py</span><br><span class="line">from haystack import indexes</span><br><span class="line">from . import models</span><br><span class="line"></span><br><span class="line">class UserIndex(indexes.SearchIndex, indexes.Indexable):</span><br><span class="line">    text = indexes.CharField(document=True, use_template=True)</span><br><span class="line"></span><br><span class="line">    def get_model(self):</span><br><span class="line">        return models.User # 当前模型文件下需要被检索的模型类</span><br><span class="line"></span><br><span class="line">    def index_queryset(self, using=None):</span><br><span class="line">        return self.get_model().objects.all()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该类为索引类，类名为模型类的名称<code>+Index</code>：比如模型类为<code>People</code>,则这里类名为<code>PeopleIndex</code></p>
<p><code>get_model</code>函数用来获取当前索引类所关联的模型类，这里我们关联上面的<code>User</code> 类对象</p>
<p><code>text=indexes.CharField</code>语句指定了将模型类中的哪些字段建立索引，而<code>use_template=True</code>说明后续我们将通过一个<strong>数据模板</strong>文件来指明需要检索的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; document=True</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>为什么要创建索引：索引就像是一本书的目录，可以为读者提供更快速的导航与查找</p>
</blockquote>
<h3 id="创建模板数据文件"><a href="#创建模板数据文件" class="headerlink" title="创建模板数据文件"></a>创建模板数据文件</h3><ul>
<li>创建数据模板文件</li>
</ul>
<blockquote>
<p>数据模板文件路径：<code>templates/search/indexes/yourapp/note_text.txt</code></p>
<p>放在任何一个你的<code>Django</code>能搜索到的模板文件夹<code>template</code>下面均可，这个文件主要确定要检索的字段，为他们建立索引</p>
<p>文件名必须为要索引的类名<code>_text.txt</code>，比如这里我们检索的类名是<code>User</code>，那么对应的数据模板文件名为<code>user_text.txt</code>，文件名小写即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#template.search.indexes.people.user_text.txt</span><br><span class="line">&#123;&#123; object.name &#125;&#125;</span><br><span class="line">&#123;&#123; object.account &#125;&#125;</span><br><span class="line">&#123;&#123; object.online_time &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在数据模板文件中使用模板语法，写入需要建立索引的字段，这里我们将模型类中<code>name</code>、<code>account</code>以及<code>online_time</code>字段设置索引，当检索时会对这三个字段去做全文检索</p>
</blockquote>
<blockquote>
<p>接下来创建一个搜索结果展示页面</p>
</blockquote>
<h3 id="检索结果模板页面"><a href="#检索结果模板页面" class="headerlink" title="检索结果模板页面"></a>检索结果模板页面</h3><ul>
<li>创建检索结果展示页面</li>
</ul>
<blockquote>
<p>检索结果展示页面，需要在固定的目录路径下进行模板页面的编写</p>
<p>路径为：<code>templates/search/</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#123;% if query %&#125;</span><br><span class="line">    &lt;h3&gt;搜索结果如下：&lt;/h3&gt;</span><br><span class="line">    &#123;% for result in page.object_list %&#125;</span><br><span class="line">        &#123;&#123; result.object.name &#125;&#125;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &#123;&#123; result.object.account &#125;&#125;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &#123;&#123; result.object.online_time &#125;&#125;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        &lt;p&gt;没找到&lt;/p&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;% if page.has_previous or page.has_next %&#125;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;% if page.has_previous %&#125;</span><br><span class="line">            	&lt;a href=&quot;?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.previous_page_number &#125;&#125;&quot;&gt;</span><br><span class="line">            		上一页</span><br><span class="line">            	&lt;/a&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">            &#123;% if page.has_next %&#125;</span><br><span class="line">            	&lt;a href=&quot;?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.next_page_number &#125;&#125;&quot;&gt;</span><br><span class="line">            		下一页</span><br><span class="line">            	&lt;/a&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个模板页面中已经自带了分页功能，可以按照需求修改</p>
</blockquote>
<ul>
<li>创建检索模板页面内容</li>
</ul>
<blockquote>
<p>还需要有一个表单，提交检索信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method=&apos;get&apos; action=&quot;/search/&quot; &gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;q&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这部分检索的模板页面内容可以在你的项目中进行添加，查询方式为<code>get</code>，并且检索输入的表单框<code>name</code>属性必须为<code>q</code></p>
</blockquote>
<h3 id="中文分词配置"><a href="#中文分词配置" class="headerlink" title="中文分词配置"></a>中文分词配置</h3><ul>
<li>接下来，需要创建有关中文检索的配置文件，这里的配置文件创建为全局</li>
</ul>
<blockquote>
<p>进入到<code>python</code>的安装目录下，比如我的目录为：<code>C:\Python37\Lib\site-packages\haystack\backends</code></p>
<p>在该路径下创建名为<code>ChineseAnalyzer.py</code>的中文分词文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import jieba</span><br><span class="line">from whoosh.analysis import Tokenizer, Token</span><br><span class="line"></span><br><span class="line">class ChineseTokenizer(Tokenizer):</span><br><span class="line">    def __call__(self, value, positions=False, chars=False,</span><br><span class="line">                 keeporiginal=False, removestops=True,start_pos=0, start_char=0, mode=&apos;&apos;, **kwargs):</span><br><span class="line">        t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs)</span><br><span class="line">        seglist = jieba.cut(value, cut_all=True)</span><br><span class="line">        for w in seglist:</span><br><span class="line">            t.original = t.text = w</span><br><span class="line">            t.boost = 1.0</span><br><span class="line">            if positions:</span><br><span class="line">                t.pos = start_pos + value.find(w)</span><br><span class="line">            if chars:</span><br><span class="line">                t.startchar = start_char + value.find(w)</span><br><span class="line">                t.endchar = start_char + value.find(w) + len(w)</span><br><span class="line">            yield t</span><br><span class="line"></span><br><span class="line">def ChineseAnalyzer():</span><br><span class="line">    return ChineseTokenizer()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个文件中，定义了一个<code>ChineseAnalyzer</code>的函数，这个函数将替代搜索引擎配置文件中的分词方式</p>
</blockquote>
<ul>
<li>复制引擎文件，修改分词方式为中文</li>
</ul>
<blockquote>
<p>同样在该文件夹下<code>C:\Python37\Lib\site-packages\haystack\backends</code>，复制<code>whoosh_backend.py</code>文件，创建一个新的文件名为<code>whoosh_cn_backend.py</code>，这里复制出一份文件也是为了之后如果不需要使用中文分词，可以直接在<code>settings</code>配置文件中修改引擎为<code>&#39;ENGINE&#39;:&#39;haystack.backends.whoosh_backend.WhooshEngine&#39;,</code></p>
</blockquote>
<blockquote>
<p>修改该引擎配置文件中的：<code>analyzer=StemmingAnalyzer()</code>变为<code>analyzer=ChineseAnalyzer()</code></p>
<p>并且要记得在头部引入刚才所编写的中文分词文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#whoosh_cn_backend.py</span><br><span class="line">from .ChineseAnalyzer import ChineseAnalyzer</span><br></pre></td></tr></table></figure>

<h3 id="初始化索引"><a href="#初始化索引" class="headerlink" title="初始化索引"></a>初始化索引</h3><ul>
<li>最后，初始化索引数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py rebuild_index</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵机制</title>
    <url>/2018/08/11/Redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Redis-哨兵机制"><a href="#Redis-哨兵机制" class="headerlink" title="Redis 哨兵机制"></a>Redis 哨兵机制</h1><h3 id="什么是哨兵机制？"><a href="#什么是哨兵机制？" class="headerlink" title="什么是哨兵机制？"></a>什么是哨兵机制？</h3><ul>
<li><p>Redis 的哨兵（sentinel）系统用于管理多个 Redis 服务器，<strong>哨兵是redis集群架构中非常重要的一个组件</strong>，该系统执行以下三个任务：</p>
<a id="more"></a>

<ul>
<li><strong>监控（Monitoring）</strong>：哨兵（sentinel）会不断地检查你的 Master 和Slave 是否运作正常。</li>
<li><strong>提醒（Notification）</strong>：当别监控的某个 Redis 出现问题时，哨兵（sentinel）可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong>：当一个Master 不能正常工作时，哨兵（sentinel）会开始一次自动故障迁移操作，它会将失效 Master 的其中一个 Slave 升级为新的 Master，并让失效 Master 的其他 Slave 改为复制新的 Master；当客户端视图连接失败的 Master时，集群也会向客户端返回新 Master 的地址，使得集群可以使用 Master 代替失效 Master。</li>
</ul>
</li>
<li><p><strong>哨兵（sentinel）是一个分布式系统，作为一个哨兵集群去运行的，相互协同工作，你可以在一个架构中运行多个哨兵（sentinel）进程</strong></p>
<blockquote>
<p>​        (1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。<br>​         (2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。        </p>
<p>​        这些进程使用留言协议（gossipprotocols）来接收关于Master 是否下线的信息，并使用投票协议 （agreementprotocols）来决定是否执行自动故障迁移，以及选择哪个 Slave 作为新的 Master。</p>
<p>​        每个哨兵（sentinel）会向其它哨兵（sentinel）、master、slave<strong>定时</strong>发送消息，以确认对方是否 <strong>“活“ **着，如果发现对方在指定时间（可配置）内未响应，则暂时认为对方已挂（所谓的</strong>”主观认为冗机“**Subjective Down,简称sdown)）</p>
<p>​        若<strong>“哨兵群”</strong>中的多数据sentinel，都报告某一 master 没响应，系统才认为该 master <strong>“彻底死亡”</strong>(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。</p>
<p>​         虽然<strong>哨兵(sentinel) *<em>释出为一个单独的可执行文件 *</em>redis-sentinel **,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定</strong> –sentinel** 选项来启动<strong>哨兵(sentinel)</strong>。</p>
</blockquote>
<p>​         哨兵(sentinel) 的一些设计思路和zookeeper非常类似</p>
<p><img src="/2018/08/11/Redis哨兵机制/20171004163652928.jpg" alt></p>
</li>
</ul>
<h3 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h3><hr>
<ul>
<li><p>哨兵至少需要3个实例，来保证自己的健壮性。</p>
</li>
<li><p>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性</p>
</li>
<li><p>对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充分的测试和演练。</p>
</li>
</ul>
<h3 id="redis哨兵主备切换的数据丢失问题"><a href="#redis哨兵主备切换的数据丢失问题" class="headerlink" title="redis哨兵主备切换的数据丢失问题"></a>redis哨兵主备切换的数据丢失问题</h3><hr>
<p>两种丢失情况：</p>
<ul>
<li><p>异步复制导致的数据丢失</p>
<blockquote>
<p>​        因为master-&gt;slave的复制是异步的，所 以可能有部分数据还没复制到slave，master就宕机了，这些数据就丢失了。</p>
</blockquote>
</li>
<li><p>脑裂导致的数据丢失</p>
<blockquote>
<p>​        脑裂，也就是说，某个master所在机器 突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着<br> ​        这个时候，集群中就会出现两个master。<br> ​        此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master数据可能就会丢失。<br> ​        因此master在恢复的时候，会被作为一个slave挂到新的master上，自己的数据会被清空，从新的master复制数据</p>
</blockquote>
</li>
</ul>
<h3 id="解决异步复制和脑裂导致的数据丢失"><a href="#解决异步复制和脑裂导致的数据丢失" class="headerlink" title="解决异步复制和脑裂导致的数据丢失"></a>解决异步复制和脑裂导致的数据丢失</h3><hr>
<p>min-slaves-to-write 1<br> min-slaves-max-lag 10<br> 要求至少有1个slave，数据复制和同步的延迟不能超过10秒<br> 如果说一旦所有slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了。<br> （1）减少异步复制的数据丢失<br> 有了min-slaves-max-lag这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内<br> （2）减少脑裂的数据丢失<br> 如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求<br> 这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失<br> 上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求<br> 因此在脑裂场景下，最多就丢失10秒的数据</p>
<p><img src="/2018/08/11/Redis哨兵机制/%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98.jpg" alt></p>
<p>集群脑裂导致的数据丢失问题.png</p>
<p><img src="/2018/08/11/Redis哨兵机制/160983038536.jpg" alt></p>
<p>脑裂导致数据丢失的问题如何降低损失.png</p>
<p><img src="/2018/08/11/Redis哨兵机制/16098303.jpg" alt></p>
<p>异步复制导致的数据丢失问题.png</p>
<p><img src="/2018/08/11/Redis哨兵机制/16098303d31754.jpg" alt></p>
<h3 id="哨兵模式的配置修改"><a href="#哨兵模式的配置修改" class="headerlink" title="哨兵模式的配置修改"></a>哨兵模式的配置修改</h3><hr>
<ul>
<li>实现步骤<ul>
<li>拷贝到etc目录<ul>
<li><strong>cp sentinel.conf /usr/local/redis/etc</strong></li>
</ul>
</li>
<li>修改sentinel.conf配置文件<ul>
<li><strong>sentinel monitor mymast 192.168.110.133 6379 1</strong> #主节点 名称 IP 端口号 选举次数</li>
<li>#配置主服务器的密码(如没设置密码，可以省略)<br>  <strong>sentinel auth-pass mymaster 123456</strong> </li>
</ul>
</li>
<li>修改心跳检测 5000毫秒<ul>
<li><strong>sentinel down-after-milliseconds mymaster 5000</strong></li>
</ul>
</li>
<li>做多多少合格节点<ul>
<li><strong>sentinel parallel-syncs mymaster 2</strong></li>
</ul>
</li>
<li>启动哨兵模式<ul>
<li><strong>./redis-server /usr/local/redis/etc/sentinel.conf –sentinel &amp;</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：</p>
<p>1.当启动哨兵模式之后，如果你的master服务器宕机之后，哨兵自动会在从redis服务器里面 投票选举一个master主服务器出来；这个主服务器也可以进行<strong>读写</strong>操作！</p>
<p>2.如果之前宕机的主服务器已经修好，可以正式运行了。那么这个服务器只能进行<strong>读</strong>的操作，会自动跟随由哨兵选举出来的新服务器！</p>
<p>3.大家可以进入./redis-cli，输入<strong>info，</strong>查看你的状态信息；</p>
</blockquote>
<p><img src="/2018/08/11/Redis哨兵机制/20171004170405127.jpg" alt></p>
<h3 id="哨兵-Sentinel-总结"><a href="#哨兵-Sentinel-总结" class="headerlink" title="哨兵(Sentinel)总结"></a>哨兵(Sentinel)总结</h3><blockquote>
<p>1、<strong>Sentinel</strong>的作用：</p>
<p>A、Master 状态监测</p>
<p>B、如果Master 异常，则会进行Master-slave 转换，将其中一个Slave作为Master，将之前的Master作为Slave </p>
<p>C、Master-Slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换 </p>
<p>2、<strong>Sentinel</strong>的工作方式<strong>:</strong></p>
<p>1)：每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。</p>
<p>2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。 </p>
<p>3)：如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 </p>
<p>4)：当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。</p>
<p>5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。</p>
<p>6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。</p>
<p>7)：若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 </p>
<p>若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</p>
<p>最后，如果大家看不太懂，推荐大家看两个博客，就明白了！</p>
<p>1.<a href="http://blog.csdn.net/zbw18297786698/article/details/52891695" target="_blank" rel="noopener">http://blog.csdn.net/zbw18297786698/article/details/52891695</a><br>2.<a href="http://blog.csdn.net/candy_rainbow/article/details/52842402" target="_blank" rel="noopener">http://blog.csdn.net/candy_rainbow/article/details/52842402</a>    </p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis哨兵机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux四剑客</title>
    <url>/2018/08/08/Linux%E5%9B%9B%E5%89%91%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>有四个剑客，他们很厉害</p>
</blockquote>
<h2 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h2><blockquote>
<p>查询命令，就是<code>find</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usage: find [-H | -L | -P] [-EXdsx] [-f path] path ... [expression]</span><br><span class="line">       find [-H | -L | -P] [-EXdsx] -f path [path ...] [expression]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ul>
<li>常用参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-name   	file		    				#查找名为file的文件；</span><br><span class="line">-type   	b/d/c/p/l/f			    #查是块设备、目录、字符设备、管道、符号链接、普通文件；</span><br><span class="line">-size     n[c]     		    		#查长度为n块[或n字节]的文件；</span><br><span class="line">-perm               					#按执行权限来查找；</span><br><span class="line">-user    	username   					#按文件属主来查找；</span><br><span class="line">-group   	groupname  					#按组来查找；</span><br><span class="line">-mtime    -n +n     					#按文件更改时间来查找文件，-n指n天以内，+n指n天以前；</span><br><span class="line">-atime    -n +n     			    #按文件访问时间来查找文件；</span><br><span class="line">-ctime    -n +n     			    #按文件创建时间来查找文件；</span><br><span class="line">-mmin     -n +n     			    #按文件更改时间来查找文件，-n指n分钟以内，+n指n分钟以前；</span><br><span class="line">-amin     -n +n     			    #按文件访问时间来查找文件；</span><br><span class="line">-cmin     -n +n     			    #按文件创建时间来查找文件；</span><br><span class="line">-nogroup            			    #查无有效属组的文件；</span><br><span class="line">-nouser             			    #查无有效属主的文件；</span><br><span class="line">-newer   	f1 !f2     			    #找文件，-n指n天以内，+n指n天以前；</span><br><span class="line">-depth              			    #使查找在进入子目录前先行查找完本目录；</span><br><span class="line">-fstype             			    #查更改时间比f1新但比f2旧的文件；</span><br><span class="line">-mount              			    #查文件时不跨越文件系统mount点；</span><br><span class="line">-follow             			    #如果遇到符号链接文件，就跟踪链接所指的文件；</span><br><span class="line">-cpio              						#查位于某一类型文件系统中的文件；</span><br><span class="line">-prune              			    #忽略某个目录；</span><br><span class="line">-maxdepth											#查找目录级别深度</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-name</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /home/ -name &apos;file&apos;</span><br><span class="line"># 查询home目录下文件名为file的文件</span><br><span class="line">find /home/ -name &apos;[a-z]*&apos;</span><br><span class="line"># 查找home目录下文件名以小写字母开头的文件</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-type</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /home/ -type d </span><br><span class="line"># 查找home目录下的目录</span><br><span class="line">find /home/ ! -type d</span><br><span class="line"># 查找home目录下的非目录</span><br><span class="line">find /home -type d | xargs chmod 755 -R</span><br><span class="line"># 查找home目录下的目录，并将这个目录里的文件的权限设置为755</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-size</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /home/ -size +1K</span><br><span class="line"># 查找home目录下文件大于1K的文件</span><br><span class="line">find /home/ -size -1M</span><br><span class="line"># 查找home目录下文件小于1M的文件</span><br><span class="line">find /home/ -size 10K</span><br><span class="line"># 查找home目录下文件等于10K的文件</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-perm</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /home/ -perm -775</span><br><span class="line"># 减号代表的意思是 比当前775更充足的权限 所有1的部分必须被匹配</span><br><span class="line">find /home/ -perm +001</span><br><span class="line"># 加号代表的意思是 只要有权限位置符合查询条件即可</span><br><span class="line">find /home/ -perm 644</span><br><span class="line"># 查询 644的文件及目录</span><br></pre></td></tr></table></figure>

<h2 id="Grep"><a href="#Grep" class="headerlink" title="Grep"></a>Grep</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Global search regular expression</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usage: grep [-abcDEFGHhIiJLlmnOoqRSsUVvwxZ] [-A num] [-B num] [-C[num]]</span><br><span class="line">	[-e pattern] [-f file] [--binary-files=value] [--color=when]</span><br><span class="line">	[--context[=num]] [--directories=action] [--label] [--line-buffered]</span><br><span class="line">	[--null] [pattern] [file ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>常用参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a 						# 以文本文件方式搜索；</span><br><span class="line">-c 						# 计算找到的符合行的次数；</span><br><span class="line">-i 						# 忽略大小写；</span><br><span class="line">-n 						# 顺便输出行号；</span><br><span class="line">-v 						# 反向选择，即显示不包含匹配文本的所有行；</span><br><span class="line">-h 						# 查询多文件时不显示文件名；</span><br><span class="line">-l 						# 查询多文件时只输出包含匹配字符的文件名；</span><br><span class="line">-s 						# 不显示不存在或无匹配文本的错误信息；</span><br><span class="line">-E 						# 允许使用egrep扩展模式匹配。</span><br></pre></td></tr></table></figure>

<ul>
<li>常用通配符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*							# 0个或者多个字符、数字；</span><br><span class="line">?							# 匹配任意一个字符；</span><br><span class="line">#							# 表示注解；</span><br><span class="line">|							# 管道符号；</span><br><span class="line">;							# 多个命令连续执行；</span><br><span class="line">&amp;							# 后台运行指令；</span><br><span class="line">!							# 逻辑运算非；</span><br><span class="line">[]						# 内容范围，匹配括号中内容；</span><br><span class="line">&#123;&#125;						# 命令块，多个命令匹配</span><br></pre></td></tr></table></figure>

<ul>
<li>正则表达式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*							# 前一个字符匹配0次或多次</span><br><span class="line">+							# 前面的正则表达式1次或多次</span><br><span class="line">?							# 前面的正则表达式出现0次或多次</span><br><span class="line">^							# 匹配行首，即以某个字符开头；</span><br><span class="line">$							# 匹配行尾，即以某个字符结尾；</span><br><span class="line">\(..\) 				# 标记匹配字符；</span><br><span class="line">[]						# 匹配中括号里的任意指定字符，但只匹配一个字符；</span><br><span class="line">[^]						# 匹配除中括号以外的任意一个字符；</span><br><span class="line">\							# 转义符，取消特殊含义；</span><br><span class="line">\&lt; 						# 锚定单词的开始；</span><br><span class="line">\&gt; 						# 锚定单词的结束；</span><br><span class="line">&#123;n&#125;						# 匹配字符出现n次；</span><br><span class="line">&#123;n,&#125;					# 匹配字符出现大于等于n次；</span><br><span class="line">&#123;n,m&#125;					# 匹配字符至少出现n次，最多出现m次；</span><br><span class="line">\w 						# 匹配文字和数字字符；</span><br><span class="line">\W 						# \w的反置形式，匹配一个或多个非单词字符；</span><br><span class="line">\b 						# 单词锁定符；</span><br><span class="line">\s						# 匹配任何空白字符；</span><br><span class="line">\d						# 匹配一个数字字符，等价于[0-9]</span><br></pre></td></tr></table></figure>

<ul>
<li>练一个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询文件ip地址</span><br></pre></td></tr></table></figure>

<h2 id="Awk"><a href="#Awk" class="headerlink" title="Awk"></a>Awk</h2><blockquote>
<p><code>AWK</code>是一个优良的文本处理工具，<a href="http://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>及<a href="http://baike.baidu.com/item/Unix" target="_blank" rel="noopener">Unix</a>环境中现有的功能最强大的数据处理引擎之一</p>
<p>以<code>Aho</code>、<code>Weinberger</code>、<code>Kernighan</code>三位发明者名字首字母命名为<code>AWK</code>，<code>AWK</code>是一个行级文本高效处理工具</p>
<p><code>AWK</code>经过改进生成的新的版本有<code>Nawk</code>、<code>Gawk</code>，一般Linux默认为<code>Gawk</code>，<code>Gawk</code>是 <code>AWK</code>的<code>GNU</code>开源免费版本，也就是我们现在所使用的版本</p>
</blockquote>
<blockquote>
<p><code>AWK</code>基本原理是逐行处理文件中的数据，查找与命令行中所给定内容相匹配的模式</p>
<p>如果发现匹配内容，则进行下一个编程步骤，如果找不到匹配内容，则 继续处理下一行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usage: awk [-F fs] [-v var=value] [-f progfile | &apos;prog&apos;] [file ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>内置变量</li>
</ul>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FS</code></td>
<td align="left">分隔符</td>
</tr>
<tr>
<td align="left"><code>OFS</code></td>
<td align="left">输出分隔符</td>
</tr>
<tr>
<td align="left"><code>NR</code></td>
<td align="left">当前行数，从<code>-1</code>开始</td>
</tr>
<tr>
<td align="left"><code>NF</code></td>
<td align="left">当前记录字段个数</td>
</tr>
<tr>
<td align="left"><code>$0</code></td>
<td align="left">当前记录</td>
</tr>
<tr>
<td align="left"><code>$1~$n</code></td>
<td align="left">当前记录第n个字段（列）</td>
</tr>
</tbody></table>
<ul>
<li>内置函数</li>
</ul>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>gsub(r, s)</code></td>
<td align="left">在<code>$0</code>中用<code>s</code>代替<code>r</code></td>
</tr>
<tr>
<td align="left"><code>index(s, t)</code></td>
<td align="left">返回<code>s</code>中<code>t</code>的第一个位置</td>
</tr>
<tr>
<td align="left"><code>length(s)</code></td>
<td align="left"><code>s</code>的长度</td>
</tr>
<tr>
<td align="left"><code>match(s, r)</code></td>
<td align="left"><code>s</code>是否匹配<code>r</code></td>
</tr>
<tr>
<td align="left"><code>split(s, a, fs)</code></td>
<td align="left">在<code>fs</code></td>
</tr>
<tr>
<td align="left"><code>substr(s, p</code></td>
<td align="left">返回<code>s</code>从<code>p</code>开始的子串</td>
</tr>
</tbody></table>
<ul>
<li>操作符</li>
</ul>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">++、–</td>
<td align="left">增加或减少</td>
</tr>
<tr>
<td align="left">^、**</td>
<td align="left">指数</td>
</tr>
<tr>
<td align="left">!、+、-</td>
<td align="left">非、一元加减</td>
</tr>
<tr>
<td align="left">+、-、*、/、%、</td>
<td align="left">四则运算、取余</td>
</tr>
<tr>
<td align="left">&lt;&lt;、&lt;=、==、!=、&gt;=、&gt;</td>
<td align="left">比较大小</td>
</tr>
<tr>
<td align="left">&amp;&amp;、||</td>
<td align="left">逻辑and、逻辑or</td>
</tr>
<tr>
<td align="left">=、+=、-=、<em>=、/=、%=、^=、*</em>=</td>
<td align="left">赋值</td>
</tr>
</tbody></table>
<h2 id="Sed"><a href="#Sed" class="headerlink" title="Sed"></a>Sed</h2><blockquote>
<p>在处理文本时把当前处理的行存储在临时缓冲区中，称为：模式空间，<strong>pattern space</strong></p>
<p>然后SED命令处理缓冲区中的内容，处理完成后将缓冲区的内容输出至屏幕或者写入文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x                   				# x为指定行号；</span><br><span class="line">x,y                 		    # 指定从x到y的行号范围；</span><br><span class="line">/pattern/           		    # 查询包含模式的行；</span><br><span class="line">/pattern/pattern/   		    # 查询包含两个模式的行；</span><br><span class="line">/pattern/,x         		    # 从与pattern的匹配行到x号行之间的行；</span><br><span class="line">x,/pattern/         		    # 从x号行到与pattern的匹配行之间的行；</span><br><span class="line">x,y!                		    # 查询不包括x和y行号的行；</span><br><span class="line">r                						# 从另一个文件中读文件；</span><br><span class="line">w                						# 将文本写入到一个文件；</span><br><span class="line">y                						# 变换字符；</span><br><span class="line">q             							# 第一个模式匹配完成后退出；</span><br><span class="line">l                						# 显示与八进制ASCII码等价的控制字符；</span><br><span class="line">&#123;&#125;              			    	# 在定位行执行的命令组；</span><br><span class="line">p                						# 打印匹配行；</span><br><span class="line">=                						# 打印文件行号；</span><br><span class="line">a\              			    	# 在定位行号之后追加文本信息；</span><br><span class="line">i\              			    	# 在定位行号之前插入文本信息；</span><br><span class="line">d                						# 删除定位行；</span><br><span class="line">c\              			    	# 用新文本替换定位文本；</span><br><span class="line">s                						# 使用替换模式替换相应模式；</span><br><span class="line">n                						# 读取下一个输入行，用下一个命令处理新的行；</span><br><span class="line">N                           # 将当前读入行的下一行读取到当前的模式空间。</span><br><span class="line">h                						# 将模式缓冲区的文本复制到保持缓冲区；</span><br><span class="line">H                						# 将模式缓冲区的文本追加到保持缓冲区；</span><br><span class="line">x                						# 互换模式缓冲区和保持缓冲区的内容；</span><br><span class="line">g                						# 将保持缓冲区的内容复制到模式缓冲区；</span><br><span class="line">G                						# 将保持缓冲区的内容追加到模式缓冲区。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>sed</strong>工具默认处理文本，文本内容输出屏幕已经修改，但是文件内容其实没有修改</p>
<p>需要加<strong>-i</strong>参数即对文件彻底修改；</p>
</blockquote>
<ul>
<li>查看文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat -n file | sed -n &quot;p&quot;</span><br><span class="line"># 查看file文件 并且阅读其中所有行，因p前无规则</span><br><span class="line">cat -n file | sed -n &quot;1,3p&quot;</span><br><span class="line"># 查看file文件 1-3行</span><br><span class="line">sed &quot;1p;\$p&quot; file</span><br><span class="line">sed &apos;1p;$p&apos; file</span><br><span class="line"># 查看文件第一行和最后一行</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &apos;1,3d&apos; file</span><br><span class="line"># 删除文件第一到第三行</span><br><span class="line">sed &apos;$d&apos; file</span><br><span class="line"># 删除文件最后一行</span><br><span class="line">sed -i &apos;/#*/d&apos; file</span><br><span class="line"># 删除文件中以#号开头的行</span><br></pre></td></tr></table></figure>

<ul>
<li>替换文本内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &apos;s/old/new/g&apos; file</span><br><span class="line">sed -i &apos;s/old/new/g&apos; file # 加了-i那么修改会影响到原本的文件对象</span><br><span class="line"># 替换file文件中的old内容为new</span><br><span class="line">#	s:使用替换模式替换相应模式</span><br><span class="line"># g:将保持缓冲区的内容复制到模式缓冲区；</span><br></pre></td></tr></table></figure>

<ul>
<li>追加文本内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &quot;/###/a 123123123&quot; file</span><br><span class="line"># 在file的符合###匹配的 后面加一行123123123</span><br><span class="line">sed &quot;1,3a 123123123&quot; file</span><br><span class="line"># 在文件的1，3行追加123123123</span><br></pre></td></tr></table></figure>

<ul>
<li>插入文本内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &quot;/###/a 123123123&quot; file</span><br><span class="line"># 在file的符合###匹配的 前面加一行123123123</span><br><span class="line">sed &quot;1,3a 123123123&quot; file</span><br><span class="line"># 在文件的1，3行前面加123123123</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerFile</title>
    <url>/2017/10/06/DockerFile/</url>
    <content><![CDATA[<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h4 id="1、DockerFile简介"><a href="#1、DockerFile简介" class="headerlink" title="1、DockerFile简介"></a>1、DockerFile简介</h4><ul>
<li>DockerFile是用来构建Docker镜像的<strong>构建文件</strong>，是由一系列命令和参数构成的脚本</li>
<li>构建步骤（1）编写DockerFile文件（2）执行docker build（3）docker run</li>
</ul><a id="more"></a>
<h4 id="2、DockerFile构建过程解析"><a href="#2、DockerFile构建过程解析" class="headerlink" title="2、DockerFile构建过程解析"></a>2、DockerFile构建过程解析</h4><ul>
<li>编写规范<ul>
<li>每条保留字指令都必须为大写字母且必须跟参数：例如 FROM nginx</li>
<li>指令从上到下，顺序执行</li>
<li>表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ul>
</li>
<li>编写步骤<ul>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器做出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都指向完成</li>
</ul>
</li>
</ul>
<blockquote>
<p>dockerfile、镜像、容器之间的关系可以类比为生产环境中的，原材料，交付品，运行的产品</p>
</blockquote>
<h4 id="3、常用关键字（语法）"><a href="#3、常用关键字（语法）" class="headerlink" title="3、常用关键字（语法）"></a>3、常用关键字（语法）</h4><table>
<thead>
<tr>
<th>关键字</th>
<th>释意</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>基础镜像，当前新镜像的父镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像维护者的姓名和邮箱</td>
</tr>
<tr>
<td>RUN</td>
<td>容器构建需要运行的命令，用&amp;&amp;连接脚本可以减少镜像的层数</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>当前容器对外暴露出的端口</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定在创建容器后，终端默认登录进来的目录</td>
</tr>
<tr>
<td>ENV</td>
<td>构建过程中的环境变量</td>
</tr>
<tr>
<td>ADD</td>
<td>将宿主机文件拷贝进镜像内并解压缩</td>
</tr>
<tr>
<td>COPY</td>
<td>拷贝文件到镜像中</td>
</tr>
<tr>
<td>VOLUME</td>
<td>容器数据卷，数据保存和持久化</td>
</tr>
<tr>
<td>CMD</td>
<td>指定容器需要运行的命令，多个命令出现时只执行最后一个CMD命令</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定容器需要运行的命令</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像内触发</td>
</tr>
</tbody></table>
<h4 id="4、案例解析"><a href="#4、案例解析" class="headerlink" title="4、案例解析"></a>4、案例解析</h4><ul>
<li>以官方centos7镜像为例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD centos-7-x86_64-docker.tar.xz /</span><br><span class="line"></span><br><span class="line">LABEL org.label-schema.schema-version="1.0" \</span><br><span class="line">    org.label-schema.name="CentOS Base Image" \</span><br><span class="line">    org.label-schema.vendor="CentOS" \</span><br><span class="line">    org.label-schema.license="GPLv2" \</span><br><span class="line">    org.label-schema.build-date="20191001"</span><br><span class="line"></span><br><span class="line">CMD ["/bin/bash"]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方仓库里的centos为精简压缩版，我们可centos添加额外功能，例如：netstat查看所有端口。</p>
<p>尝试编写Dockerfile来实现这一功能</p>
</blockquote>
<p>任意目录下新建DockerFile空文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch DockerFile</span><br><span class="line">vi DockerFile</span><br></pre></td></tr></table></figure>

<p>写入可执行文本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">ENV mypath /home</span><br><span class="line">WORKDIR $mypath</span><br><span class="line">RUN yum -y install net-tools &amp;&amp; touch 1.txt</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p>docker build执行DockerFile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t centos:1.1 -f DockerFile .</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-t  指定镜像的名字。[name:版本 =&gt; centos:1.1]</p>
</li>
<li><p>-f  显示指定构建镜像的 Dockerfile 文件（Dockerfile 可不在当前路径下）。如果不使用 -f，则默认将上下文路径下的名为 Dockerfile 的文件认为是构建镜像的 “Dockerfile” </p>
</li>
<li><p>.  这个表示打包的上下文（其实就是Dockerfile所在目录）是在当前目录。指定构建镜像的上下文的路径，构建镜像的过程中，可以且只可以引用上下文中的任何文件 </p>
</li>
</ul>
<blockquote>
<p>docker build 官方语法 “docker build [OPTIONS] PATH | URL | -”。</p>
<p>更多详情请参考：<a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/build/</a></p>
</blockquote>
<p>查看是否安装了netstat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -t -i -d centos /bin/bash</span><br><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript</title>
    <url>/2017/09/15/javascript/</url>
    <content><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><blockquote>
<p><code>JavaScript</code>是运行在浏览器端的脚本语言，<code>JavaScript</code>主要解决的是前端与用户交互的问题</p>
<p>是一种动态性、弱类型的语言；</p>
<p>他的解释器就在我们的浏览器中，是浏览器的一部分</p>
<p>这门语言对<strong>大小写敏感</strong>，并会忽略多余的空格，可以使用<code>\</code>进行代码换行，注释使用<code>//</code>或<code>/**/</code></p>
</blockquote>
<a id="more"></a>



<ul>
<li>主要由三部分组成<ul>
<li><code>ECMAScript</code>：语言的语法和基本对象</li>
<li>文档对象模型<code>Dom(Document Object Model)</code>：处理网页内容的方法和接口</li>
<li>浏览器对象模型<code>Bom(BrowserObjectModel)</code>：与浏览器进行交互的方法和接口</li>
</ul>
</li>
<li>前端三大部<ul>
<li><code>HTML</code>：页面的内容、结构</li>
<li><code>CSS</code>：页面的表现形式、<strong>部分动画</strong></li>
<li><code>JavaScript</code>：页面的行为、交互、<strong>功能</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="JavaScript引入"><a href="#JavaScript引入" class="headerlink" title="JavaScript引入"></a>JavaScript引入</h3><ul>
<li>行间事件：为某一个具体的元素标签赋予<code>js</code>内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert(&apos;点我&apos;);&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>嵌入引入：在文档页面通过<code>Script</code>标签嵌入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;&lt;/title&gt;</span><br><span class="line">	&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">		alert(&quot;ok!&quot;);</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>外部引入：定义单独<code>js</code>文件，通过<code>script</code>标签进行引入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/main.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>alert</code>函数用来展示一个提示框</p>
</blockquote>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 1</span><br><span class="line">var y = &quot;2&quot;</span><br><span class="line">var z = 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义变量需要使用关键字：<code>var</code></p>
<ul>
<li>同时定义多个变量可以使用 <strong>，</strong> 隔开</li>
</ul>
</li>
<li><p><strong>注意</strong>：<code>javascript</code>变量均为对象，每当声明一个变量，就相当于创建了一个对象</p>
</li>
<li><p>命名规则：</p>
<ol>
<li>区分大小写</li>
<li>首字符为<strong>字母</strong>、<strong>数字</strong>、<strong>下划线</strong><code>_</code>、或<strong>美元符号</strong><code>$</code></li>
<li>其他字符可以为<strong>字母</strong>、<strong>数字</strong>、<strong>下划线</strong>、<strong>美元符号</strong></li>
</ol>
</li>
<li><p>调试程序的方法：</p>
<ul>
<li><code>alert</code>：弹框</li>
<li><code>console.log()</code>：浏览器控制台</li>
<li><code>document.title()</code>：页面标题</li>
</ul>
</li>
</ul>
<hr>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li><code>Number</code>：<strong>数字类型</strong>，可以带小数点，也可以不带</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 1.5;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>String</code>：<strong>字符串类型</strong>，可以使用<strong>单引号</strong>或<strong>双引号</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = &quot;abc&quot;;</span><br><span class="line">var b = &quot;aaaa&quot; + 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Boolean</code>：<strong>布尔类型</strong>，只能是<code>true</code>|<code>false</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = true;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>undefined</code>：<strong>未定义类型</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>null</code>：<strong>空对象类型</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = null;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看变量数据类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;abc&quot;;</span><br><span class="line">alert(typeof x)</span><br></pre></td></tr></table></figure>

<ul>
<li>匈牙利命名规则：<ul>
<li>对象 <code>o</code> (<code>Object</code>)：<code>oPerson</code></li>
<li>数组 <code>a</code> (<code>Array</code>)：<code>aUsers</code></li>
<li>字符串 <code>s</code> (<code>String</code>)：<code>sAccount</code></li>
<li>整数 <code>i</code> (<code>Integer</code>)：<code>iScore</code></li>
<li>布尔值 <code>b</code> (<code>Boolean</code>)：<code>bIsLogin</code></li>
<li>浮点数 <code>f</code> (<code>Float</code>)：<code>fPrice</code></li>
<li>函数 <code>f</code> (<code>Function</code>)：<code>fEats</code></li>
<li>正则 <code>re</code> (<code>RegExp</code>)：<code>reIDCard</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>转换为字符串：<code>toString</code>，支持<code>Boolean</code>、<code>Number</code>、<code>String</code>三种主要类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var y = &quot;abc&quot;;</span><br><span class="line">var z = true;</span><br><span class="line">alert(x.toString()) // &quot;1&quot;</span><br><span class="line">alert(y.toString()) // &quot;abc&quot;</span><br><span class="line">alert(z.toString()) // &quot;true&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>转换为数字：<strong>parseInt</strong>、<strong>parseFloat</strong>，将只含有数字的字符串变为整形或浮点型，其他类型返回<code>NaN</code>()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;123&quot;</span><br><span class="line">var y = &quot;123.01&quot;</span><br><span class="line">var z = &quot;123aa&quot;</span><br><span class="line">alert(parseInt(x)) // 123</span><br><span class="line">alert(parseFloat(x)) // 123</span><br><span class="line">alert(parseInt(y)) // 123</span><br><span class="line">alert(parseFloat(y)) // 123.01</span><br><span class="line">alert(parseInt(z)) // 123</span><br><span class="line">alert(parseFloat(z)) // 123</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：<code>parseFloat</code>转换的包含浮点数的字符串应该是十进制</li>
</ul>
<blockquote>
<p>八进制或十六进制，该方法会忽略前导<code>0</code></p>
<p>八进制数字<code>020</code>会被解析为<code>20</code></p>
<p>十六进制数字<code>0xFF</code>，会返回<code>Nan</code>，因为x符号不是有效字符</p>
</blockquote>
<hr>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul>
<li><code>Boolean()</code>：当要转换的值是至少有一个字符的字符串</li>
</ul>
<blockquote>
<p>非<code>0</code>数字或对象时，<code>Boolean()</code>函数将返回<code>true</code></p>
<p>如果该值是空字符串、数字<code>0</code>、<code>undefined</code>或<code>null</code>，它将返回<code>false</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(Boolean(0)) // false</span><br><span class="line">alert(Boolean(1)) // true</span><br><span class="line">alert(Boolean(&quot;1&quot;)) // true</span><br><span class="line">alert(Boolean(&quot;1a&quot;)) // true</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Number()</code>：换与<code>parseInt()</code>和<code>parseFloat()</code>方法的处理方式相似，只是它转换的是整个值，而不是部分值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(Number(false)) // 0</span><br><span class="line">alert(Number(true)) // 1</span><br><span class="line">alert(Number(undefined)) // NaN</span><br><span class="line">alert(Number(null)) // 0</span><br><span class="line">alert(Number(&quot;1.2&quot;)) // 1.2</span><br><span class="line">alert(Number(&quot;12&quot;)) // 12</span><br><span class="line">alert(Number(&quot;1.2.3&quot;)) // NaN</span><br><span class="line">alert(Number(new object())) // NaN</span><br><span class="line">alert(Number(50)) // 50</span><br></pre></td></tr></table></figure>

<ul>
<li><code>String()</code>：可把任何值转换成字符串</li>
<li><strong>注意</strong>：强制转换成字符串和调用<code>toString()</code>方法的唯一不同之处在于，对<code>null</code>和<code>undefined</code>值强制类型转换可以生成字符串而不引发错误</li>
</ul>
<hr>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul>
<li><code>Array</code>：数组，索引从<code>0</code>开始</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var people = [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;];</span><br><span class="line">var people = new Array(&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;);</span><br><span class="line">var people = new Array();</span><br><span class="line">people[0] = &quot;张三&quot;</span><br><span class="line">people[1] = &quot;李四&quot;</span><br><span class="line">people[2] = &quot;王五&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Object</code>：对象，就像是字典，定义时<code>key</code>值不需要设置类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;张三&quot;,</span><br><span class="line">    age: 18,</span><br><span class="line">    sex: &quot;male&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">/*对象有两种访问方式：*/</span><br><span class="line">person[&quot;name&quot;]</span><br><span class="line">person.name</span><br><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;张三&quot;;</span><br><span class="line">person.age = 17;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>函数语法：包裹在<strong>花括号</strong>中的代码块，前面使用了关键词<code>function</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&quot;func()&quot;&gt;点击这里&lt;/button&gt;</span><br><span class="line">function func(arg1,arg2,...) &#123;</span><br><span class="line">    alert(&quot;函数被执行&quot;)</span><br><span class="line">    // 执行代码</span><br><span class="line">    return 1; // return是可选的，并且可以不写返回值，单纯只做函数终止</span><br><span class="line">&#125;</span><br><span class="line">// 函数名 func</span><br><span class="line">// 参数 arg1,arg2,...</span><br><span class="line">// 返回值 return 1</span><br><span class="line">func() // 函数执行</span><br></pre></td></tr></table></figure>

<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul>
<li><strong>局部变量</strong></li>
</ul>
<blockquote>
<p>在<code>JavaScript</code>函数内部声明的变量（使用<code>var</code>）是<strong>局部</strong>变量，</p>
<p>只能在函数内部访问它</p>
<p>该变量的作用域是局部的</p>
<p><strong>生命周期</strong>：局部变量会在函数运行以后被删除 (生命期从它们被声明的时间开始)</p>
</blockquote>
<ul>
<li><strong>全局变量</strong></li>
</ul>
<blockquote>
<p>在函数外声明的变量是<strong>全局</strong>变量</p>
<p>网页上的所有脚本和函数都能访问它</p>
<p><strong>生命周期</strong>：全局变量会在页面关闭后被删除 (生命期从它们被声明的时间开始)</p>
</blockquote>
<ul>
<li>局部变量如果希望变为全局变量、可以使用<code>windows.var =</code>的形式赋予给当前窗口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">window.x = x;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func(x,y)&#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">var res = func(1,2)</span><br><span class="line">alert(res)</span><br></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JavaScript</span><br></pre></td></tr></table></figure>

<p>函数解析过程：</p>
<ol>
<li><strong>预编译</strong>：<code>function</code>函数提前，并将<code>var</code>定义的变量声明提前，先暂时赋值为<code>undefined</code></li>
<li><strong>执行</strong></li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func() // 弹出提示</span><br><span class="line">alert(iNum) // undefined</span><br><span class="line">alert(abc) // 出错</span><br><span class="line">function func() &#123;</span><br><span class="line">    alert(&quot;这个是函数&quot;)</span><br><span class="line">&#125;</span><br><span class="line">var iNum = 1</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul>
<li>函数可以没有名字，比如直接为某些事件赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">	var sDate = new Date()</span><br><span class="line">	console.log(sDate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="封闭函数"><a href="#封闭函数" class="headerlink" title="封闭函数"></a>封闭函数</h4><ul>
<li>封闭函数常用来创建一个开始就执行而不用命名的函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    alert(&quot;你好&quot;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以在函数定义前加上”<code>~</code>“和”<code>!</code>“等符号来定义匿名函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!function()&#123;</span><br><span class="line">    alert(&quot;你好&quot;);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<ul>
<li>封闭函数可以创建一个独立的空间，在封闭函数内定义的变量不会影响外部同名的函数和变量，可以避免命名冲突</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">!function()&#123;</span><br><span class="line">	var x = &quot;这是同名变量&quot;;</span><br><span class="line">    alert(x);</span><br><span class="line">&#125;</span><br><span class="line">alert(x);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当页面上引入多个<code>js</code>文件时，用这种办法比较安全</p>
</blockquote>
<hr>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">示例</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+</code></td>
<td align="left">加</td>
<td align="left"><code>x=y+2</code></td>
<td align="left"><code>x=7</code></td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">减</td>
<td align="left"><code>x=y-2</code></td>
<td align="left"><code>x=3</code></td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td align="left">乘</td>
<td align="left"><code>x=y*2</code></td>
<td align="left"><code>x=10</code></td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left">除</td>
<td align="left"><code>x=y/2</code></td>
<td align="left"><code>x=2.5</code></td>
</tr>
<tr>
<td align="left"><code>%</code></td>
<td align="left">取余</td>
<td align="left"><code>x=y%2</code></td>
<td align="left"><code>x=1</code></td>
</tr>
<tr>
<td align="left"><code>++</code></td>
<td align="left">累加</td>
<td align="left"><code>x=++y</code></td>
<td align="left"><code>x=6</code></td>
</tr>
<tr>
<td align="left"><code>--</code></td>
<td align="left">递减</td>
<td align="left"><code>x=--y</code></td>
<td align="left"><code>x=4</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">例子</th>
<th align="left">等价于</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>=</code></td>
<td align="left"><code>x=y</code></td>
<td align="left"></td>
<td align="left"><code>x=5</code></td>
</tr>
<tr>
<td align="left"><code>+=</code></td>
<td align="left"><code>x+=y</code></td>
<td align="left"><code>x=x+y</code></td>
<td align="left"><code>x=15</code></td>
</tr>
<tr>
<td align="left"><code>-=</code></td>
<td align="left"><code>x-=y</code></td>
<td align="left"><code>x=x-y</code></td>
<td align="left"><code>x=5</code></td>
</tr>
<tr>
<td align="left"><code>*=</code></td>
<td align="left"><code>x*=y</code></td>
<td align="left"><code>x=x*y</code></td>
<td align="left"><code>x=50</code></td>
</tr>
<tr>
<td align="left"><code>/=</code></td>
<td align="left"><code>x/=y</code></td>
<td align="left"><code>x=x/y</code></td>
<td align="left"><code>x=2</code></td>
</tr>
<tr>
<td align="left"><code>%=</code></td>
<td align="left"><code>x%=y</code></td>
<td align="left"><code>x=x%y</code></td>
<td align="left"><code>x=0</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>注意</strong>：<strong>数字与字符串相加，结果将成为字符串</strong></li>
</ul>
<hr>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>==</code></td>
<td align="left">等于</td>
<td align="left"><code>x==8</code>为<code>false</code></td>
</tr>
<tr>
<td align="left"><code>===</code></td>
<td align="left">全等（值和类型）</td>
<td align="left"><code>x===5</code>为<code>true</code>；<code>x===&quot;5&quot;</code>为<code>false</code></td>
</tr>
<tr>
<td align="left"><code>!=</code></td>
<td align="left">不等于</td>
<td align="left"><code>x!=8</code>为<code>true</code></td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">大于</td>
<td align="left"><code>x&gt;8</code>为<code>false</code></td>
</tr>
<tr>
<td align="left"><code>&lt;</code></td>
<td align="left">小于</td>
<td align="left"><code>x&lt;8</code>为<code>true</code></td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td align="left">大于或等于</td>
<td align="left"><code>x&gt;=8</code>为<code>false</code></td>
</tr>
<tr>
<td align="left"><code>&lt;=</code></td>
<td align="left">小于或等于</td>
<td align="left"><code>x&lt;=8</code>为<code>true</code></td>
</tr>
</tbody></table>
<ul>
<li>比较运算符常在条件语句中进行使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;张三&quot;;</span><br><span class="line"> 	if (name==&quot;张三&quot;) &#123;</span><br><span class="line"> 		document.write(&quot;这个人是张三&quot;)</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&amp;&amp;</code></td>
<td align="left"><code>and</code></td>
<td align="left"><code>(x &lt; 10 &amp;&amp; y &gt; 1)</code> 为 <code>true</code></td>
</tr>
<tr>
<td align="left">`</td>
<td align="left"></td>
<td align="left">`</td>
</tr>
<tr>
<td align="left"><code>!</code></td>
<td align="left"><code>not</code></td>
<td align="left"><code>!(x==y)</code> 为 <code>true</code></td>
</tr>
</tbody></table>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var NumCheck = 0; </span><br><span class="line">var Dis = (NumCheck==0) ? &quot;是数字0&quot;:&quot;不是数字0&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果变量<code>NumCheck</code>是<code>0</code>，则<code>Dis</code>的值为：”是数字<code>0</code>“；反之为：”不是数字<code>0</code>“</li>
</ul>
<hr>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul>
<li>条件语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var iNum = 0;</span><br><span class="line">if (iNum==0)&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;else if (iNum==1) &#123;</span><br><span class="line">   	条件细分...;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	不满足以上条件均到这里;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>switch</code>语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var day = new Date().getDay();</span><br><span class="line">// 星期日:0  范围:0~6</span><br><span class="line">switch(day)&#123;</span><br><span class="line">	case 0:</span><br><span class="line">		alert(&quot;今天是星期二&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case 1:</span><br><span class="line">		...</span><br><span class="line">		break;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>工作原理</strong>：首先设置表达式<code>n</code>（通常是一个变量）；随后表达式的值会与结构中的每个<code>case</code>的值做比较。如果存在匹配，则与该<code>case</code>关联的代码块会被执行。请使用<em>break</em>来阻止代码自动地向下一个<code>case</code>运行</li>
</ul>
<hr>
<h3 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h3><ul>
<li><strong>语法</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i = 0; i &lt; len; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// for(起点数据; 判断条件; 数据递增或递减)&#123;&#125;</span><br><span class="line">var i = 0;</span><br><span class="line">for( ;i &lt; 10; i++)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">// 如果循环起始值已经被设置，可以在开头省略</span><br><span class="line">for(var i = 0; ; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (i==5)&#123;</span><br><span class="line">        ...</span><br><span class="line">        break; //终止循环</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 当没有第二个语句时，必须在循环内提供break，否则循环则无法停下来，可能令浏览器崩溃</span><br><span class="line">for(var i = 0; i &lt; 10; )&#123;</span><br><span class="line">   	console.log(i);</span><br><span class="line">    i += 2;</span><br><span class="line">&#125;</span><br><span class="line">// 如果没有提供第三个语句，可以在for循环中进行编写数值的变化</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for/in</code>语句循环遍历对象的属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (x in object)&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// 字符串：x 取下标</span><br><span class="line">// 数组：x 取下标</span><br><span class="line">// 对象：x 取key</span><br><span class="line">var x = &quot;abcdef&quot;  // 0,1,2,3,4,5</span><br><span class="line">var y = [1,2,3,4,&quot;5&quot;] // 0,1,2,3,4</span><br><span class="line">var z = &#123; //  name,age,gender</span><br><span class="line">    name:&quot;张三&quot;,</span><br><span class="line">    age:16,</span><br><span class="line">    gender:&quot;male&quot;,</span><br><span class="line">&#125;</span><br><span class="line">for (obj in z)&#123;</span><br><span class="line">    console.log(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h3><ul>
<li>语法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (条件)&#123;</span><br><span class="line">    执行代码;</span><br><span class="line">&#125;</span><br><span class="line">var x = &quot;abcdef&quot;;</span><br><span class="line">var i = 0;</span><br><span class="line">while (x[i])&#123;</span><br><span class="line">    console.log(x[i]);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">// 下表超出范围时不会报错，返回undefined</span><br></pre></td></tr></table></figure>

<ul>
<li><code>do/while</code>循环：<code>do/while</code>循环是<code>while</code>循环的变体</li>
</ul>
<blockquote>
<p>该循环首先会执行一次循环代码块，然后检查循环条件是否为真</p>
<p>如果条件为真，就会重复这个循环</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	循环执行代码</span><br><span class="line">&#125;while (条件);</span><br><span class="line">var i = 3;</span><br><span class="line">do&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">    i--;</span><br><span class="line">&#125;while (i &gt; 5);</span><br><span class="line">// do/while循环至少会执行一次</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="获取页面元素"><a href="#获取页面元素" class="headerlink" title="获取页面元素"></a>获取页面元素</h3><ul>
<li>通过页面元素<code>ID</code>值进行获取：<code>document.getElementById(&#39;&#39;)</code><ul>
<li>获取到的是一个<code>HTML</code>对象，可以赋值给一个变量</li>
</ul>
</li>
<li><strong>注意</strong>：获取对应元素时，首先要确定页面已经生成所需元素</li>
</ul>
<blockquote>
<p>通常我们将<code>javascript</code>代码写到页面最下面</p>
<p>或通过使用<code>windows.onload()</code>事件判断是否已经生成页面</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p id=&quot;p&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		function func()&#123;</span><br><span class="line">			var sP = document.getElementById(&apos;p&apos;);</span><br><span class="line">			console.log(sP);</span><br><span class="line">		&#125;</span><br><span class="line">		func()</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-- 获取到的内容: &lt;p id=&quot;p&quot;&gt;这是一段待获取的文字&lt;/p&gt; --&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p id=&quot;p&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		window.onload = function()&#123;</span><br><span class="line">			var sP = document.getElementById(&apos;p&apos;);</span><br><span class="line">			console.log(sP);</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-- 获取到的内容: &lt;p id=&quot;p&quot;&gt;这是一段待获取的文字&lt;/p&gt; --&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="操作页面元素"><a href="#操作页面元素" class="headerlink" title="操作页面元素"></a>操作页面元素</h3><ul>
<li>可以通过<code>id</code>方式获取到对应页面内的元素，就可以对元素的属性进行操作，包括对属性的读和写</li>
<li>读取元素属性：元素<code>.</code>属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;aaa&quot; style=&quot;color: red;&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var oP = document.getElementById(&apos;aaa&apos;);</span><br><span class="line">    console.log(oP)</span><br><span class="line">    console.log(oP.id);</span><br><span class="line">    console.log(oP.style);</span><br><span class="line">    console.log(oP.style.color);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改元素属性：元素.属性 =<code>xxx</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;aaa&quot; style=&quot;color: red;&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">&lt;button onclick=&quot;blue_font()&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function blue_font()&#123;</span><br><span class="line">        var oP = document.getElementById(&apos;aaa&apos;);</span><br><span class="line">        oP.style.color = &quot;blue&quot;;</span><br><span class="line">        // 修改字体样式属性中的字体颜色为蓝色</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p id=&quot;aaa&quot; style=&quot;color: red;&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">&lt;button id=&quot;color_button&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    color_button.onclick = function()&#123;</span><br><span class="line">        var oP = document.getElementById(&apos;aaa&apos;);</span><br><span class="line">        oP.style.color = &quot;blue&quot;;</span><br><span class="line">        // 修改字体样式属性中的字体颜色为蓝色</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以获取到对应按钮元素后在绑定函数到它</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;aaa&quot; style=&quot;color: red;&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">&lt;button id=&quot;Button&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var oButton = document.getElementById(&apos;Button&apos;);</span><br><span class="line">    oButton.onclick = function()&#123;</span><br><span class="line">        var oP = document.getElementById(&apos;aaa&apos;);</span><br><span class="line">        oP.style.color = &quot;blue&quot;;</span><br><span class="line">        // 修改字体样式属性中的字体颜色为蓝色</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取或写入标签包裹的内容（读取或修改标签文本内容）：<code>innerHTML</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a id=&quot;a&quot; href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;</span><br><span class="line">&lt;button onclick=&quot;urlChange()&quot;&gt;变搜狗&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function urlChange()&#123;</span><br><span class="line">        var oA = document.getElementById(&apos;a&apos;);</span><br><span class="line">        oA.href = &quot;https://www.sougou.com&quot;;</span><br><span class="line">        console.log(oA.innerHTML); // 获取标签文本内容</span><br><span class="line">        oA.innerHTML = &quot;搜狗&quot;; //修改标签文本内容</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="JS事件及属性"><a href="#JS事件及属性" class="headerlink" title="JS事件及属性"></a>JS事件及属性</h3><ul>
<li>常见事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 用户点击鼠标</span><br><span class="line">- 网页已加载</span><br><span class="line">- 图像已加载</span><br><span class="line">- 鼠标移动某个元素上</span><br><span class="line">- 输入字段被改变时</span><br><span class="line">- 提交表单时</span><br><span class="line">- 用户触发某些按键时</span><br></pre></td></tr></table></figure>

<ul>
<li><code>onclick</code>事件：用户点击鼠标</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p onclick=&quot;TextChange(this)&quot;&gt;这是文本&lt;/p&gt;</span><br><span class="line">&lt;!-- this 代表当前所处的元素 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function TextChange(id)&#123;</span><br><span class="line">        id.innerHTML = &quot;文本修改&quot;//可以直接通过传来的参数进行页面元素的读取及修改</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p id=&quot;p&quot;&gt;这是文本&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var oP = document.getElementById(&quot;p&quot;);</span><br><span class="line">    oP.onclick = function()&#123;</span><br><span class="line">        oP.innerHTML = &quot;文本修改&quot;//可以直接通过传来的参数进行页面元素的读取及修改</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>onmouseover</code>事件：鼠标移入</li>
<li><code>onmouseout</code>事件：鼠标移出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;aaa&quot;&gt;请把鼠标移动过来&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var oP = document.getElementById(&quot;aaa&quot;);</span><br><span class="line">    oP.onmouseover = function()&#123;</span><br><span class="line">        oP.style.color = &quot;green&quot;;//可以直接通过传来的参数进行页面元素的读取及修改</span><br><span class="line">    &#125;</span><br><span class="line">    oP.onmouseout = function()&#123;</span><br><span class="line">        oP.style.color = &quot;red&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="JS高级"><a href="#JS高级" class="headerlink" title="JS高级"></a>JS高级</h2><h3 id="字符串及操作方法"><a href="#字符串及操作方法" class="headerlink" title="字符串及操作方法"></a>字符串及操作方法</h3><ul>
<li>字符串合并：<code>+</code></li>
<li>数字字符串变整数：<code>parseInt()</code></li>
<li>数字字符串变浮点数：<code>parseFloat()</code></li>
<li>字符串按分隔符切分：<code>split(&quot;*&quot;)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;a*b*c*d&quot;</span><br><span class="line">alert(x.split(&quot;*&quot;)) // a,b,c,d</span><br><span class="line">console.log(x.split(&quot;*&quot;)) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li>查找字符串是否含有某字符，找到返回索引，找不到返回-1：<code>String.indexOf()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;abcdefag&quot;</span><br><span class="line">var res = x.indexOf(&quot;z&quot;)</span><br><span class="line">alert(res)</span><br></pre></td></tr></table></figure>

<ul>
<li>截取字符串：<code>String.substring(start, end)</code>，不包含end索引位置数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;abcdefag&quot;</span><br><span class="line">alert(x.substring(2)) // cdefag</span><br><span class="line">alert(x.substring(2,4)) // cd</span><br><span class="line">alert(x.substring()) // abcdefag</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串反转：通过结合数组的<code>reverse()</code>函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;abcd&quot;;</span><br><span class="line">console.log(x.split(&quot;&quot;).reverse().join(&quot;&quot;)) //dcba</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="数组及操作方法"><a href="#数组及操作方法" class="headerlink" title="数组及操作方法"></a>数组及操作方法</h3><ul>
<li>定义数组的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = new Array(1,2,3);</span><br><span class="line">var aList = new Array();</span><br><span class="line">aList[0] = &quot;a&quot;;</span><br><span class="line">aList[1] = &quot;b&quot;;</span><br><span class="line">var aList = [1,2,3,4,&quot;a&quot;];</span><br></pre></td></tr></table></figure>

<ul>
<li>获取数组的长度：<code>Array.length()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = new Array(1,2,3);</span><br><span class="line">console.log(aList.length) // 3</span><br></pre></td></tr></table></figure>

<ul>
<li>将数组成员通过指定拼接符合并成一个字符串：<code>Array.join(&quot;*&quot;)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,3,4,5]</span><br><span class="line">console.log(aList.join(&quot;*&quot;)) // 1*2*3*4*5</span><br></pre></td></tr></table></figure>

<ul>
<li>向数组的<strong>最后</strong>增加或删除成员：<code>Array.pop()</code>、<code>Array.push()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,3,4,5]</span><br><span class="line">var opa = aList.pop() // opa: 5</span><br><span class="line">console.log(opa) // 5</span><br><span class="line">console.log(aList) // [1, 2, 3, 4]</span><br><span class="line">aList.push(&quot;a&quot;)</span><br><span class="line">console.log(aList) // [1, 2, 3, 4, &quot;a&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li>将数组反转：<code>Array.reverse()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,3,4,5];</span><br><span class="line">aList.reverse();</span><br><span class="line">console.log(aList); //[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>

<ul>
<li>返回数组中元素第一次出现的索引值：<code>Array.indexOf(chr)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,3,4,5];</span><br><span class="line">console.log(aList.indexOf(3)) // 2</span><br></pre></td></tr></table></figure>

<ul>
<li>在数组中增加或删除成员，并返回被删除的：<code>Array.splice(index, howmany, items...)</code></li>
</ul>
<blockquote>
<p>从<code>index</code>位置开始，给定的<code>hwomany</code>个数的值，并用后面的<code>items</code>替换这些被<strong>删除</strong>的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,&quot;a&quot;,4,5]</span><br><span class="line">aList.splice(2,1,&quot;b&quot;,&quot;c&quot;)</span><br><span class="line">console.log(aList) // [1, 2, &quot;b&quot;, &quot;c&quot;, 4, 5]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><blockquote>
<p>数组的成员包含数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,3,[&quot;a&quot;,&quot;b&quot;]]</span><br><span class="line">console.log(aList[-1][0]) // 出错 undefined</span><br><span class="line">console.log(aList[3][0]) // a</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li>作用：定时调用函数、制作动画</li>
</ul>
<hr>
<h4 id="反复执行定时器"><a href="#反复执行定时器" class="headerlink" title="反复执行定时器"></a>反复执行定时器</h4><ul>
<li><code>setInterval(code, millisec)</code>：反复执行的定时器</li>
<li><code>code</code>: 必须参数，要调用的函数或要执行的代码串<ul>
<li><code>millisec</code>: 必须参数，执行<code>code</code>任务所需要的事件间隔，以毫秒计</li>
</ul>
</li>
<li><code>clearInterval(setInterval_obj)</code>：<strong>关闭</strong>反复执行的定时器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--跑马灯效果--&gt;</span><br><span class="line">&lt;h3 id=&quot;h3&quot;&gt;abcdefg&lt;/h3&gt;</span><br><span class="line">&lt;button id=&quot;start_button&quot;&gt;开始&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;stop_button&quot;&gt;停止&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    start_button.onclick = function()&#123; // 开启定时事件</span><br><span class="line">    	var sT = setInterval(loop,1000);</span><br><span class="line">    	window.sT = sT; // 声明此sT定时事件为全局变量</span><br><span class="line">	&#125;</span><br><span class="line">    stop_button.onclick = function()&#123; // 关闭定时事件</span><br><span class="line">        clearInterval(sT)</span><br><span class="line">    &#125;</span><br><span class="line">    function loop()&#123;</span><br><span class="line">        var Opstr = document.getElementById(&apos;h3&apos;);</span><br><span class="line">        Opstr.innerHTML = Opstr.innerHTML.substring(1) + Opstr.innerHTML[0]</span><br><span class="line">        console.log(Opstr.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="等待执行定时器"><a href="#等待执行定时器" class="headerlink" title="等待执行定时器"></a>等待执行定时器</h4><ul>
<li><p><code>setTimeout(code, millisec)</code>：定义只执行一次的等待定时器</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code</span><br></pre></td></tr></table></figure>

<p>: 必须参数，要调用的函数或要执行的代码串</p>
<ul>
<li><code>millisec</code>: 必须参数，执行<code>code</code>任务所需要的事件间隔，以毫秒计</li>
</ul>
</li>
<li><p><code>clearTimeout(setTimeout_obj)</code>：关闭只执行一次的等待计时器</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h3 id=&quot;h3&quot;&gt;我是一个内容&lt;/h3&gt;</span><br><span class="line">&lt;button id=&quot;start_button&quot;&gt;让上面的内容消失&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    start_button.onclick = function()&#123;</span><br><span class="line">        var st = setTimeout(clear,1000)</span><br><span class="line">        window.st = st;</span><br><span class="line">    &#125;</span><br><span class="line">    function clear()&#123;</span><br><span class="line">        var oH3 = document.getElementById(&apos;h3&apos;);</span><br><span class="line">        oH3.innerHTML = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 事务、乐观锁、分布式锁、信号量</title>
    <url>/2017/09/12/redis%E4%BA%8B%E5%8A%A1%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><blockquote>
<p>Redis是一款内存高速缓存数据库，该软件使用C语言编写，</p>
<p>Redis是一个key - value 存储系统，它支持丰富的数据类型，</p>
<p>如：String、List、Set、Hash。</p>
<p>是为了解决高并发、高扩展，大数据存储等问题！</p>
</blockquote><a id="more"></a>
<ul>
<li>读写效率高，持久化、丰富的特性</li>
</ul>
<blockquote>
<p>读写效率高：读写速度最高可达 <code>10万次/s+</code>。</p>
<p>持久化：断电或重启后，数据也不会丢失。因为 Redis 的存储分为内存存储、磁盘存储和 log 文件三部分，中启后，Redis可以从磁盘将数据加载到内存中。</p>
<p>丰富的特性：建空间、事务、订阅发布功能、计数。</p>
</blockquote>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><ul>
<li><p>回顾Mysql 数据库事务</p>
<ul>
<li>什么是事务，事务是原子操作，里面的操作，要么都成功，要么都不成功。</li>
</ul>
</li>
<li><p>原子性</p>
<ul>
<li>整个事务的操作，要么都成功，要么都不成功，如果在执行的过程中，发生了错误，就回滚到开始的状态。</li>
</ul>
</li>
<li><p>一致性</p>
<ul>
<li>在事务的开始前，和结束后，数据的完整性约束，没有被破坏。</li>
</ul>
</li>
<li><p>隔离性</p>
<ul>
<li>使得同一时间，只有一个请求同一数据。</li>
</ul>
</li>
<li><p>持久性</p>
<ul>
<li>事务成功之后，对数据库的操作会，永远的保存在数据库当中。</li>
</ul>
</li>
<li><p><strong>Redsi</strong>事务</p>
<blockquote>
<p>Redis 事务的本质：</p>
<p>​        是将一组操作放入队列中，批量执行，过程中如果产生了某个命令错误，不会回滚，其他正确的命令，仍然会继续执行</p>
</blockquote>
</li>
<li><p>与 mysql 对比</p>
<ul>
<li><p>redis 是  ：</p>
<p>​    开始事务   multi（）</p>
<p>​    提交事务  execute（）</p>
<p>​    放弃事务  reset（）</p>
</li>
</ul>
</li>
</ul>
<h3 id="什么时候用到锁"><a href="#什么时候用到锁" class="headerlink" title="什么时候用到锁"></a>什么时候用到锁</h3><ul>
<li>锁的生命周期<ul>
<li>任务通过竞争获取锁才能对资源进行操作 （竞争锁）</li>
<li>当任务在对资源进行操作时！（占有锁）</li>
<li>其它任务都不可以对这个资源操作 （任务阻塞）</li>
<li>直到该任务完成更新 （释放锁）</li>
</ul>
</li>
</ul>
<h3 id="redis-乐观锁的使用"><a href="#redis-乐观锁的使用" class="headerlink" title="redis 乐观锁的使用"></a>redis 乐观锁的使用</h3><ul>
<li><p>乐观锁：</p>
<blockquote>
<p>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去跟新这个数据</p>
</blockquote>
</li>
<li><p>redis 中的乐观锁：</p>
<blockquote>
<p>可以使用 watch（）方法来实现，可以监控一个或多个键，再事务执行的过程中，其中的一个键发生了改变，那么这个事务，就不会执行。</p>
</blockquote>
</li>
</ul>
<h3 id="redis-实现分布式锁"><a href="#redis-实现分布式锁" class="headerlink" title="redis 实现分布式锁"></a>redis 实现分布式锁</h3><ul>
<li><p>什么是分布式锁：</p>
<blockquote>
<p>控制分布式系统有序的去对共享资源进行操作，通过互斥来保持一致性。</p>
</blockquote>
<p><a href="https://v.qq.com/x/page/n3026r8xhil.html" target="_blank" rel="noopener">https://v.qq.com/x/page/n3026r8xhil.html</a></p>
</li>
<li><p>SETNX（）</p>
<blockquote>
<p>这个命令会在键不存在的情况下为键设置值，如果存在的情况下则不作任何操作！</p>
<p>setnx 是『SET if Not eXists』(如果不存在，则 SET)的简写。 <strong>命令格式</strong>：SETNX key value；使用：只在键 key 不存在的情况下，将键 key 的值设置为 value 。</p>
</blockquote>
</li>
<li><p>获取锁</p>
<blockquote>
<p>如果程序在尝试获取锁的过程中失败，那么他将不断的进行重试，直到成功的取到锁，或者超过锁的过期时间</p>
</blockquote>
</li>
<li><p>删除锁</p>
<blockquote>
<p>删除锁之前会先判断，是否是该线程加的锁，如果是，则执行delete 进行删除。</p>
</blockquote>
</li>
</ul>
<p>####redis分布式原理一：</p>
<p><strong>过程分析：</strong></p>
<ul>
<li>A尝试去获取锁lockkey，通过setnx(lockkey,currenttime+timeout)命令，对lockkey进行setnx,将value值设置为当前时间+锁超时时间；</li>
<li>如果返回值为1，说明redis服务器中还没有lockkey，也就是没有其他用户拥有这个锁，A就能获取锁成功；</li>
<li>在进行相关业务执行之前，先执行expire(lockkey)，对lockkey设置有效期，防止死锁。因为如果不设置有效期的话，lockkey将一直存在于redis中，其他用户尝试获取锁时，执行setnx(lockkey,currenttime+timeout)时，将不能成功获取到该锁；</li>
<li>执行相关业务；</li>
<li>释放锁，A完成相关业务之后，要释放拥有的锁，也就是删除redis中该锁的内容，del(lockkey)，接下来的用户才能进行重新设置锁新值。</li>
</ul>
<p>####redis分布式原理二：（解决死锁问题）</p>
<ul>
<li>当A通过setnx(lockkey,currenttime+timeout)命令能成功设置lockkey时，即返回值为1，过程与原理1一致；</li>
<li>当A通过setnx(lockkey,currenttime+timeout)命令不能成功设置lockkey时，这是不能直接断定获取锁失败；</li>
<li>因为我们在设置锁时，设置了锁的超时时间timeout，当当前时间大于redis中存储键值为lockkey的value值时，可以认为上一任的拥有者对锁的使用权已经失效了，A就可以强行拥有该锁；具体判定过程如下；</li>
<li>A通过get(lockkey)，获取redis中的存储键值为lockkey的value值，即获取锁的相对时间lockvalueA<br>lockvalueA!=null &amp;&amp; currenttime&gt;lockvalue，A通过当前的时间与锁设置的时间做比较，如果当前时间已经大于锁设置的时间临界，即可以进一步判断是否可以获取锁，否则说明该锁还在被占用，A就还不能获取该锁，结束，获取锁失败；</li>
<li>步骤4返回结果为true后，通过getSet设置新的超时时间，并返回旧值lockvalueB，以作判断，因为在分布式环境，在进入这里时可能另外的进程获取到锁并对值进行了修改，只有旧值与返回的值一致才能说明中间未被其他进程获取到这个锁；</li>
<li>lockvalueB == null || lockvalueA==lockvalueB，判断：若果lockvalueB为null，说明该锁已经被释放了，此时该进程可以获取锁；旧值与返回的lockvalueB一致说明中间未被其他进程获取该锁，可以获取锁；否则不能获取锁，结束，获取锁失败。</li>
</ul>
<h3 id="分布式锁应该具备哪些条件"><a href="#分布式锁应该具备哪些条件" class="headerlink" title="分布式锁应该具备哪些条件"></a>分布式锁应该具备哪些条件</h3><ul>
<li>互斥性，在任意时刻，只有一个客户端能持有锁</li>
<li>高可用的获取锁和释放锁</li>
<li>具备锁失效机制，避免死锁</li>
<li>具备非阻塞锁特性，即没有获取到锁直接返回获取锁失败</li>
<li>释放锁</li>
</ul>
<p>###分布式锁和线程锁的区别：</p>
<ul>
<li>保证资源独立</li>
<li>弱化一致性</li>
<li>提升效率和可用性</li>
<li>保障资源最终一致性</li>
</ul>
<h3 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h3><blockquote>
<p>何为计数信号量？<br>简单来说就是控制对共享资源的访问。<br>实现方法： Semaphore （）<br>Semaphore 是一个计数信号量。<br>常用于限制可以访问某些资源的线程数量</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>时间模块</title>
    <url>/2017/08/06/%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h3><p>Python中有很多方便我们处理时间信息的模块</p>
<ul>
<li>*<em>time *</em>模块</li>
<li><strong>datetime</strong> 模块</li>
<li>*<em>pytz *</em>模块</li>
<li>*<em>dateutil *</em>模块</li>
</ul>
<p>这里我们着重介绍的是前两种</p>
<a id="more"></a>



<h4 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h4><blockquote>
<p><strong>time.time()</strong><br>返回当前时间于 <strong>Unix</strong>时间 <strong>(1970.1.1 00:00:00)</strong>经过的秒数<br>返回值也称作<strong>时间戳</strong>，是一个<strong>浮点数</strong>类型</p>
</blockquote>
<hr>
<blockquote>
<p><strong>time.localtime(seconds)</strong><br>将<strong>时间戳秒数</strong>转换为表示<strong>本地时间</strong>的<strong>时间元组</strong><br>如果没有传入参数，则直接返回<strong>当前本地时间</strong>的<strong>时间元组</strong></p>
<blockquote>
<p>时间元组：<strong>(tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec, tm_wday, tm_yday, tm_isdst)</strong></p>
<ul>
<li><strong>tm_wday</strong>：从0开始，表示星期几</li>
<li><strong>tm_yday</strong>：第几天</li>
<li><strong>tm_isdst</strong>：夏令时的决定旗标</li>
</ul>
</blockquote>
</blockquote>
<hr>
<blockquote>
<p><strong>time.sleep(seconds)</strong><br><strong>推迟</strong>程序的运行，参数为推迟的<strong>秒数</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>time.clock()</strong><br>一般用来衡量<strong>程序</strong>的<strong>耗时</strong></p>
<ul>
<li><p><strong>win</strong></p>
<p>：</p>
<ul>
<li>第一次调用：<strong>浮点数形式</strong>返回当前<strong>CPU</strong>运行时间</li>
<li>第二次调用：<strong>浮点数形式</strong>返回距离<strong>上次调用</strong>该函数至此次的<strong>时间间隔</strong></li>
</ul>
</li>
<li><p><strong>Linux</strong></p>
<p>：</p>
<ul>
<li>浮点数返回当前的程序执行时间</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>time.asctime(tupletime)</strong><br>将一个<strong>时间元组</strong>返回为一个<strong>可读形式</strong>字符串</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; time.asctime( time.localtime() )</span><br><span class="line">&apos;Fri Feb  2 22:26:36 2018&apos;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p><strong>time.strftime( format [, tuple] )</strong><br>将<strong>时间元组</strong>根据指定<strong>格式</strong>返回为<strong>可读字符串</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>time.strptime( string, format )</strong><br>将<strong>可读字符串</strong>根据<strong>格式</strong>返回为<strong>时间元组</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>格式</strong>：</p>
<ul>
<li><strong>%Y</strong>：年份</li>
<li><strong>%m</strong>：月份</li>
<li><strong>%d</strong>：天数</li>
<li><strong>%H</strong>：小时</li>
<li><strong>%M</strong>：分钟</li>
<li><strong>%S</strong>：秒</li>
<li><strong>%x</strong>：天/月/年</li>
<li><strong>%X</strong>：当前 时:分:秒</li>
<li><strong>%A</strong>：星期 (全称)</li>
<li><strong>%a</strong>：星期 (缩写)</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &gt;&gt;&gt; time.strftime(&apos;%Y %m %d&apos;,time.localtime())</span><br><span class="line">&apos;2018 02 02&apos;</span><br><span class="line">&gt;&gt;&gt; time.strptime(&apos;2018 02 02&apos;,&apos;%Y %m %d&apos;)</span><br><span class="line">time.struct_time(tm_year=2018, tm_mon=2, tm_mday=2, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=33, tm_isdst=-1)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h4><blockquote>
<p><strong>子模块介绍</strong>：在<strong>datetime</strong>模块分别包含了以下三个模块进行时间处理</p>
<blockquote>
<ul>
<li><strong>datetime.datetime</strong>：处理年月日，时分秒</li>
<li><strong>datetime.date</strong>：处理年月日</li>
<li><strong>datetime.time</strong>：处理时分秒</li>
</ul>
</blockquote>
</blockquote>
<hr>
<blockquote>
<p><strong>datetime.datetime.now()</strong><br><strong>datetime.datetime.today()</strong><br>获取<strong>当前时间</strong>，包含<strong>年月日</strong>，<strong>时分秒</strong>，<strong>微秒</strong><br>返回类型为<strong>datetime.datetime</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>datetime.date.today()</strong><br>返回<strong>当前时间</strong>，只包含<strong>年月日</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>datetime.datetime.delta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999)</strong><br>表示<strong>时间差</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; now = datetime.datetime.now()</span><br><span class="line">&gt;&gt;&gt; now</span><br><span class="line">datetime.datetime(2018, 2, 10, 17, 12, 18, 220858)</span><br><span class="line">&gt;&gt;&gt; de = datetime.timedelta(days=30)</span><br><span class="line">&gt;&gt;&gt; de + now</span><br><span class="line">datetime.datetime(2018, 3, 12, 17, 12, 18, 220858)</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>一些时间实例中的函数：</p>
<blockquote>
<ul>
<li><strong>res = datetime.datetime.today()</strong></li>
<li><strong>res = datetime.date.today()</strong></li>
<li><strong>res = datetime.time(10,20,10)</strong></li>
</ul>
</blockquote>
</blockquote>
<hr>
<blockquote>
<p>一些<strong>通用</strong>的<strong>实例函数</strong>，在下<strong>列举</strong>：</p>
</blockquote>
<hr>
<blockquote>
<ul>
<li>*<em>res.year *</em>：年</li>
<li><strong>res.month</strong>：月</li>
<li><strong>res.day</strong>：日</li>
<li><strong>res.hour</strong>： 时</li>
<li><strong>res.minute</strong>：分</li>
<li><strong>res.second</strong>：秒</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>res.timestamp()</strong><br>获取当前时间戳</p>
</blockquote>
<hr>
<blockquote>
<p><strong>res.timetuple()</strong><br>获取当前时间元组</p>
</blockquote>
<hr>
<blockquote>
<p><strong>res.ctime()</strong><br>返回一个字符串日期</p>
</blockquote>
<hr>
<blockquote>
<p><strong>res.replace(year, month, day, hour, minute, second)</strong><br>将指定值<strong>替换</strong>后返回一个新的<strong>date</strong>数据</p>
</blockquote>
<hr>
<blockquote>
<p><strong>res.timetuple()</strong><br>返回一个<strong>时间元组</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>res.weekday() **</strong><br>从0开始<strong>返回当前时间是星期几\</strong>星期一为0<strong>，</strong>星期日为6**</p>
</blockquote>
<hr>
<blockquote>
<p><strong>res.isoweekday()</strong><br>以<strong>ISO</strong>时间标准格式从<strong>1</strong>开始返回当前时间是星期几<br><strong>星期一为1</strong>，<strong>星期日为7</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>res.isocalendar()</strong><br><strong>ISO</strong>表示格式的<strong>时间元组</strong><br><strong>(年，月，日)</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>res.isoformat()</strong><br>返回 一个<strong>‘YYYY-MM-DD’</strong>的<strong>字符串格式</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>构造</strong>自己的时间</p>
<blockquote>
<p><strong>datetime.datetime(2018, 2, 2, 23, 11, 2, 9999)</strong><br><strong>参数位置分别为</strong>：<strong>年 月 日 时 分 秒 微秒</strong><br><strong>返回值</strong>： <strong>datetime.datetime</strong>类型</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>用户和组</title>
    <url>/2017/06/06/%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84/</url>
    <content><![CDATA[<h2 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h2><blockquote>
<p><code>Linux</code>是一个多用户的操作系统，引入用户，可以更加方便管理<code>Linux</code>服务器</p>
<p>系统默认需要以一个用户的身份登入，而且在系统上启动进程也需要以一个用户身份器运行，用户可以限制某些进程对特定资源的权限控制</p>
</blockquote><a id="more"></a>
<h3 id="Linux用户及组"><a href="#Linux用户及组" class="headerlink" title="Linux用户及组"></a>Linux用户及组</h3><blockquote>
<p><code>Linux</code>操作系统对多用户的管理，是非常繁琐的，所以用组的概念来管理用户就变得简单，每个用户可以在一个独立的组，每个组也可以有零个用户或者多个用户。</p>
<p><code>Linux</code>系统用户是根据用户<code>ID</code>来识别的，默认<code>ID</code>长度为<code>32</code>位，从默认<code>ID</code>编号从<code>0</code>开始，但是为了和老式系统兼容，用户<code>ID</code>限制在<code>60000</code>以下，<code>Linux</code>用户分总共分为三种，分别如下</p>
</blockquote>
<ul>
<li>超级用户：<code>root</code>，<code>ID</code>为0</li>
<li>系统用户：<code>ID</code>从1到499</li>
<li>普通用户：<code>ID</code>为500以上</li>
</ul>
<blockquote>
<p><code>Linux</code>系统中的每个文件或者文件夹，都有一个所属用户及所属组</p>
<p>使用<code>id</code>命令可以显示当前用户的信息，使用<code>passwd</code>命令可以修改当前用户密码。<code>Linux</code>操作系统用户的特点如下</p>
</blockquote>
<ul>
<li>每个用户拥有一个<code>UserID</code>，操作系统实际读取的是<code>UID</code>，而非用户名；</li>
<li>每个用户属于一个主组，属于一个或多个附属组，一个用户最多有<code>31</code>个附属组；</li>
<li>每个组拥有一个<code>GroupID</code>；</li>
<li>每个进程以一个用户身份运行，该用户可对进程拥有资源控制权限；</li>
<li>每个可登陆用户拥有一个指定的<code>Shell</code>环境</li>
</ul>
<h3 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h3><blockquote>
<p><code>Linux</code>用户在操作系统可以进行日常管理和维护，涉及到的相关配置文件如下</p>
</blockquote>
<ul>
<li><code>/etc/passwd</code>：保存用户信息</li>
<li><code>/etc/shadow</code>：保存用户密码（以加密形式保存）</li>
<li><code>/etc/group</code>：保存组信息</li>
<li><code>/etc/login.defs</code>：用户属性限制，密码过期时间，密码最大长度等限制</li>
<li><code>/etc/default/useradd</code>：显示或更改默认的<code>useradd</code>配置文件</li>
</ul>
<h4 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd usertest # 创建用户usertest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建新用户，可以使用命令<code>useradd</code>，执行命令即可创建新用户</p>
<p>同时会创建一个同名的组，默认该用户属于该用户组</p>
</blockquote>
<blockquote>
<p>创建用户，会根据如下步骤进行操作</p>
</blockquote>
<ul>
<li>在<code>/etc/passwd</code>文件中添加用户信息</li>
<li>如使用<code>passwd</code>命令创建密码，密码会被加密保存在<code>/etc/shdaow</code>中</li>
<li>为用户创建家目录：<code>/home/usertest</code>，创建目录操作应操作系统而异</li>
<li>将<code>/etc/skel</code>中的<code>.bash</code>开头的文件复制至用户家目录</li>
<li>创建与用户名相同的组，该用户默认属于这个同名组，组信息保存在<code>/etc/group</code>配置文件中</li>
</ul>
<blockquote>
<p>其他命令可选参数如下所示</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-d # 指定新用户的主目录</span><br><span class="line">-G # 指定新用户的组列表</span><br><span class="line">-s # 新用户所使用的shell环境</span><br><span class="line">useradd usertest -s /bin/bash -d /home/usertest</span><br><span class="line"># 创建新用户usertest，指定shell环境为bash，主目录在/home/usertest</span><br></pre></td></tr></table></figure>

<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel # 保留用户的家目录</span><br><span class="line">userdel –r usertest # 删除用户及用户家目录，用户login系统无法删除</span><br><span class="line">userdel –rf usertest # 强制删除用户及该用户家目录，不论是否login系统</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当一个用户创建之后，我们可以通过<code>usermod</code>命令来修改用户及组的属性</p>
</blockquote>
<ul>
<li><code>linux</code>下命令选项</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选项：</span><br><span class="line">  -c, --comment 注释            GECOS 字段的新值</span><br><span class="line">  -d, --home HOME_DIR           用户的新主目录</span><br><span class="line">  -e, --expiredate EXPIRE_DATE  设定帐户过期的日期为 EXPIRE_DATE</span><br><span class="line">  -f, --inactive INACTIVE       过期 INACTIVE 天数后，设定密码为失效状态</span><br><span class="line">  -g, --gid GROUP               强制使用 GROUP 为新主组</span><br><span class="line">  -G, --groups GROUPS           新的附加组列表 GROUPS</span><br><span class="line">  -a, --append GROUP            将用户追加至上边 -G 中提到的附加组中，</span><br><span class="line">                                并不从其它组中删除此用户</span><br><span class="line">  -h, --help                    显示此帮助信息并推出</span><br><span class="line">  -l, --login LOGIN             新的登录名称</span><br><span class="line">  -L, --lock                    锁定用户帐号</span><br><span class="line">  -m, --move-home               将家目录内容移至新位置 (仅于 -d 一起使用)</span><br><span class="line">  -o, --non-unique              允许使用重复的(非唯一的) UID</span><br><span class="line">  -p, --password PASSWORD       将加密过的密码 (PASSWORD) 设为新密码</span><br><span class="line">  -R, --root CHROOT_DIR         chroot 到的目录</span><br><span class="line">  -s, --shell SHELL             该用户帐号的新登录 shell</span><br><span class="line">  -u, --uid UID                 用户帐号的新 UID</span><br><span class="line">  -U, --unlock                  解锁用户帐号</span><br><span class="line">  -Z, --selinux-user  SEUSER       用户账户的新 SELinux 用户映射</span><br><span class="line">groups username</span><br><span class="line"># 查看用户所属组</span><br></pre></td></tr></table></figure>

<h4 id="修改用户所属组"><a href="#修改用户所属组" class="headerlink" title="修改用户所属组"></a>修改用户所属组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod usertest -G old_normal</span><br><span class="line"># 将用户usertest修改加入old_normal组中</span><br><span class="line">usermod usertest -a -G other_normal</span><br><span class="line"># 将用户追加至other_normal组中，且不影响原有组状态</span><br><span class="line">cat /etc/group | grep usertest </span><br><span class="line"># 可以查看到usertest用户当前所属组的情况</span><br></pre></td></tr></table></figure>

<h4 id="修改用户家目录及启动shell"><a href="#修改用户家目录及启动shell" class="headerlink" title="修改用户家目录及启动shell"></a>修改用户家目录及启动shell</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod usertest -d /home/user -s /bin/sh</span><br></pre></td></tr></table></figure>

<h4 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名"></a>修改用户名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -l new old</span><br><span class="line"># 将old用户名变为new</span><br></pre></td></tr></table></figure>

<h4 id="锁定-解锁用户"><a href="#锁定-解锁用户" class="headerlink" title="锁定/解锁用户"></a>锁定/解锁用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -L usertest;</span><br><span class="line"># 锁定usertest用户</span><br><span class="line">usermod -U usertest;</span><br><span class="line"># 解锁usertest用户</span><br></pre></td></tr></table></figure>

<h3 id="Linux组管理"><a href="#Linux组管理" class="headerlink" title="Linux组管理"></a>Linux组管理</h3><blockquote>
<p>所有的<code>Linux</code>或者<code>Windows</code>系统都有组的概念，通过组可以更加方便的管理用户</p>
<p>组的概念应用于各行行业，例如企业会使用部门、职能或地理区域的分类方式来管理成员，映射在<code>Linux</code>系统，同样可以创建用户，并用组的概念对其管理</p>
<p>Linux组有如下特点</p>
</blockquote>
<ul>
<li>每个组有一个组<code>ID</code></li>
<li>组信息保存在<code>/etc/group</code>中</li>
<li>每个用户至少拥有一个主组，同时还可以拥有<code>31</code>个附属组</li>
</ul>
<h4 id="创建新组"><a href="#创建新组" class="headerlink" title="创建新组"></a>创建新组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd normal # 创建normal组</span><br><span class="line">groupadd -g 1000 normal # 创建ID为1000的分组</span><br></pre></td></tr></table></figure>

<h4 id="其他组属性"><a href="#其他组属性" class="headerlink" title="其他组属性"></a>其他组属性</h4><blockquote>
<p>常见参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-r # 系统账户</span><br><span class="line">-f # 如果指定的组已经存在，则退出</span><br><span class="line">-g # 指定当前组id</span><br><span class="line">-n --new --old # 修改组名</span><br><span class="line">groupmod -n old_normal normal</span><br><span class="line"># 修改normal组名为old_normal</span><br><span class="line">groupmod -g 1001 old_normal</span><br><span class="line"># 修改old_normal组id为1001</span><br></pre></td></tr></table></figure>

<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><blockquote>
<p>设置好了用户和组，那么接下来就可以对其进行权限控制</p>
<p>由于linux下处处皆文件，所谓权限也就是对文件的<strong>读</strong>、<strong>写</strong>、<strong>执行</strong>，至少这三种</p>
<p>当操作系统下某个进程在运行时，进程的权限，也相当于这个进程的运行用户身份权限</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">权限</th>
<th align="left">文件</th>
<th align="left">目录</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">读取文件</td>
<td align="left">列出目录</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">修改文件</td>
<td align="left">修改目录内文件</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">执行文件</td>
<td align="left">进入目录</td>
</tr>
</tbody></table>
<ul>
<li>权限分组</li>
</ul>
<blockquote>
<p>默认的linux的权限分为三种角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; user`、`group`、`other</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>每个文件将基于<strong>UGO</strong>三种权限进行设置</p>
<p>一般一个文件创建之后，谁创建该文件，默认成为该文件的所有者</p>
</blockquote>
<h3 id="用户及组权限"><a href="#用户及组权限" class="headerlink" title="用户及组权限"></a>用户及组权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -ahl</span><br><span class="line"># 查看文件所有者</span><br><span class="line">chmod g+rwx file</span><br><span class="line"># 给file文件增加rwx权限</span><br><span class="line">chmod g-x file</span><br><span class="line"># 给file文件减少x权限</span><br></pre></td></tr></table></figure>

<h3 id="用户及组修改"><a href="#用户及组修改" class="headerlink" title="用户及组修改"></a>用户及组修改</h3><blockquote>
<p>修改某个文件或目录所属<strong>用户</strong>或<strong>组</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R root file</span><br><span class="line"># 修改file文件所属用户为root</span><br><span class="line">chown -R :root file</span><br><span class="line"># 修改file文件所属用户为root</span><br><span class="line">chgrp -R root file</span><br><span class="line"># 修改file文件所属组为root</span><br></pre></td></tr></table></figure>

<h3 id="二进制权限"><a href="#二进制权限" class="headerlink" title="二进制权限"></a>二进制权限</h3><blockquote>
<p>linux下具备权限设置为1，反之为0，那么一个权限按照二进制位数来计算，如下所示</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--x: 001 1</span><br><span class="line">-wx: 011 3</span><br><span class="line">rwx: 111 7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很清晰，对应的权限位置所代表的数字分别是：<strong>r=4</strong>，<strong>w=2</strong>，<strong>x=1</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 775 file</span><br><span class="line"># 修改file文件权限为 rwxrwxr-x</span><br></pre></td></tr></table></figure>

<h3 id="权限掩码"><a href="#权限掩码" class="headerlink" title="权限掩码"></a>权限掩码</h3><blockquote>
<p>神奇的事情需要我们考虑，每次创建文件，默认都会具备一定的权限，而这个权限是如何分配而来的呢？</p>
<p>是通过一个叫做权限掩码的东西来维护的，这个码可以通过<strong>umask</strong>命令看到</p>
<p>默认系统的掩码是<strong>022</strong></p>
</blockquote>
<ul>
<li>文件权限由默认权限减去掩码</li>
</ul>
<blockquote>
<p>文件默认权限：666<br>那么创建一个文件真实的权限是：666-022=644</p>
</blockquote>
<blockquote>
<p>目录的默认权限：777</p>
<p>一个目录的真实权限是：777-022=755</p>
</blockquote>
<ul>
<li>设置默认掩码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umask -S 011</span><br></pre></td></tr></table></figure>

<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><table>
<thead>
<tr>
<th align="left">权限</th>
<th align="left">对文件的影响</th>
<th align="left">对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>suid</strong></td>
<td align="left">以文件的所属用户身份执行，而非执行文件的用户</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><strong>sgid</strong></td>
<td align="left">以文件所属组身份去执行</td>
<td align="left">在该目录中创建任意新文件的所属组与该目录的所属组相同</td>
</tr>
<tr>
<td align="left"><strong>sticky</strong></td>
<td align="left">无</td>
<td align="left">对目录拥有写入权限的用户仅可以删除其拥有的文件，无法删除其他用户所拥有的文件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql主从复制</title>
    <url>/2017/03/02/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h2><ul>
<li>什么是<strong>主从复制</strong>？</li>
</ul>
<blockquote>
<p>主从复制至少需要两台服务器，或两个<strong>mysql</strong>服务，可以配置一主多从，多主多从</p>
<p>建立与某个业务数据库一样的数据库环境，即为主从复制</p>
<p>一般情况下，主库用以写，而从库用以读</p>
</blockquote>
<a id="more"></a>

<ul>
<li>为什么要搭建主从复制？<ol>
<li>构建主从热备，当某天数据库宕机或或数据丢失情况，可以有备份数据库继续工作</li>
<li>降低IO频次，多库之间可以合理分配读写压力，提高单个数据库服务的数据库访问压力</li>
<li>隔离读写，在某些锁表情况下，可以使数据库读操作继续进行</li>
</ol>
</li>
</ul>
<ul>
<li>主从复制原理</li>
</ul>
<blockquote>
<p>利用数据库<strong>bin-log</strong>二进制文件，该文件包含有数据库操作的所有SQL语句</p>
<p>复制该文件至其余数据库服务中并执行即可</p>
</blockquote>
<ul>
<li><p>主从复制过程</p>
<ol>
<li><p>当主库具有新数据时，主库会被从库请求，建立线程进行连接，用以传输<strong>binlog</strong>日志</p>
</li>
<li><p>从库开启两个线程</p>
<blockquote>
<p>A线程：也叫做<strong>IO线程</strong>，连接主库，并请求binlog中的更新记录至从库中，写入至从库的<strong>relaylog</strong>文件中</p>
<p>B线程：也叫做<strong>SQL线程</strong>，读取<strong>relaylog</strong>文件中的更新操作并执行</p>
</blockquote>
</li>
<li><p>如果，有多个从库同时存在，主库会为每个从库建立一个<strong>binlog</strong>输出线程</p>
</li>
</ol>
</li>
</ul>
<p><a href="https://lienze.tech/blog/images/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E8%87%AA%E7%BB%98.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E8%87%AA%E7%BB%98.png" alt="主从复制原理自绘"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy=LOW;</span><br><span class="line">set global validate_password_length=6;</span><br></pre></td></tr></table></figure>

<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote>
<p>此处以一主一丛为例</p>
</blockquote>
<ul>
<li>系统环境<ul>
<li>主库（master）：192.168.1.100</li>
<li>从库（slave）：192.168.1.101</li>
</ul>
</li>
</ul>
<h3 id="主库修改"><a href="#主库修改" class="headerlink" title="主库修改"></a>主库修改</h3><ul>
<li>主库配置修改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server-id = 1</span><br><span class="line">log-bin=mysql-bin # 开启log bin</span><br><span class="line">expire_logs_days=7 # 日志保存时间</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>server-id</strong>：</p>
<p>同步数据中必须包含<strong>server-id</strong>，用于标识该语句最初是从哪个<strong>server</strong>写入</p>
<p>每个<strong>slave</strong>端只能有一个线程在<strong>master</strong>端连接，如果两个<strong>salve</strong>端的<strong>server-id</strong>一致，一个连接成功之后，前一个连接将会被断开</p>
<p>主主同步时，避免数据同步陷入死循环</p>
</blockquote>
<ul>
<li>主库创建用户，用以从机连接获取<strong>binlog</strong>日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant replication slave on *.* to &apos;master&apos;@&apos;%&apos; identified by &apos;123456&apos;;</span><br><span class="line">flush privileges;</span><br><span class="line">grant all privileges on *.* to master@&apos;%&apos; identified by &quot;123456&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看master状态（包括日志文件名和对应位置）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<ul>
<li>记录上条命令返回的<strong>binlog</strong>文件名，<strong>Position</strong>属性，从机连接的时候要用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      154 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="从库修改"><a href="#从库修改" class="headerlink" title="从库修改"></a>从库修改</h3><ul>
<li>从库配置修改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server-id=11</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>master</strong>与<strong>slave</strong>端的<strong>server-id</strong>不能一样</p>
<p><strong>salve</strong>端无需开启<strong>log-bin</strong>功能</p>
</blockquote>
<ul>
<li>从库指定master，执行如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">change master to master_host=&apos;118.31.76.26&apos;, master_port=3306, master_user=&apos;master&apos;, master_password=&apos;123456&apos;, master_log_file=&apos;mysql-bin.000001&apos;, master_log_pos=603;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动从机</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<ul>
<li>从机连接停止（配置错误，从新连接时使用）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset slave all;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询连接状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure>

<ul>
<li>显示为正确</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">Slave_IO_State: Waiting for master to send event</span><br><span class="line">Master_Host: 192.168.1.9</span><br><span class="line">Master_User: reader</span><br><span class="line">Master_Port: 3307</span><br><span class="line">Connect_Retry: 60</span><br><span class="line">Master_Log_File: mysql-bin.000007</span><br><span class="line">Read_Master_Log_Pos: 501</span><br><span class="line">Relay_Log_File: 0b763a8d1ddd-relay-bin.000002</span><br><span class="line">Relay_Log_Pos: 320</span><br><span class="line">Relay_Master_Log_File: mysql-bin.000007</span><br><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br><span class="line">Last_IO_Error: 错误显示地方</span><br></pre></td></tr></table></figure>

<p>###项目配置</p>
<h4 id="settings-py文件"><a href="#settings-py文件" class="headerlink" title="settings.py文件"></a>settings.py文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">	<span class="string">'default'</span>: &#123;</span><br><span class="line">		<span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">		<span class="string">'HOST'</span>: <span class="string">'118.31.76.26'</span>, <span class="comment"># 数据库主机</span></span><br><span class="line">		<span class="string">'PORT'</span>: <span class="number">3306</span>, <span class="comment"># 数据库端口</span></span><br><span class="line">		<span class="string">'USER'</span>: <span class="string">'root'</span>, <span class="comment"># 数据库用户名</span></span><br><span class="line">		<span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>, <span class="comment"># 数据库用户密码</span></span><br><span class="line">		<span class="string">'NAME'</span>: <span class="string">'slave'</span> <span class="comment"># 数据库名字</span></span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="string">'slave'</span>: &#123;</span><br><span class="line">		<span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">		<span class="string">'HOST'</span>: <span class="string">'118.31.76.26'</span>, <span class="comment"># 数据库主机</span></span><br><span class="line">		<span class="string">'PORT'</span>: <span class="number">3307</span>, <span class="comment"># 数据库端口</span></span><br><span class="line">		<span class="string">'USER'</span>: <span class="string">'root'</span>, <span class="comment"># 数据库用户名</span></span><br><span class="line">		<span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>, <span class="comment"># 数据库用户密码</span></span><br><span class="line">		<span class="string">'NAME'</span>: <span class="string">'slave'</span> <span class="comment"># 数据库名字</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DATABASES_ROUTERS= [<span class="string">'slave.utils.DBrouter'</span>]</span><br></pre></td></tr></table></figure>

<h4 id="主路由下utils-py"><a href="#主路由下utils-py" class="headerlink" title="主路由下utils.py"></a>主路由下utils.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBrouter</span>:</span></span><br><span class="line">    <span class="string">"""数据库主从读写分离路由"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self,model,**hints)</span>:</span></span><br><span class="line">        <span class="string">"""读数据库"""</span></span><br><span class="line">        print(<span class="string">'给从'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'slave'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_write</span><span class="params">(self,model,**hints)</span>:</span></span><br><span class="line">        <span class="string">"""写数据库"""</span></span><br><span class="line">        print(<span class="string">'给主'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'default'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_relation</span><span class="params">(self,db1,db2,**k)</span>:</span></span><br><span class="line">        <span class="string">"""是否运行关联操作"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="同步特定的库"><a href="#同步特定的库" class="headerlink" title="同步特定的库"></a>同步特定的库</h3><h4 id="主机处配置"><a href="#主机处配置" class="headerlink" title="主机处配置"></a>主机处配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binlog-do-db=xxxx   # 二进制日志记录的数据库</span><br><span class="line">binlog-ignore-db=xxxx # 二进制日志中忽略数据库</span><br></pre></td></tr></table></figure>

<h4 id="从机处配置"><a href="#从机处配置" class="headerlink" title="从机处配置"></a>从机处配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">replicate-do-db    # 设定需要复制的数据库</span><br><span class="line">replicate-ignore-db # 设定需要忽略的复制数据库</span><br><span class="line">replicate-do-table  # 设定需要复制的表</span><br><span class="line">replicate-ignore-table # 设定需要忽略的复制表</span><br><span class="line">replicate-wild-do-table # 同replication-do-table功能一样，但是可以通配符</span><br><span class="line">replicate-wild-ignore-table # 同replication-ignore-table功能一样，但是可以加通配符</span><br></pre></td></tr></table></figure>

<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li><strong>mysql</strong>-&gt;<strong>mariadb</strong>版本问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: &apos;Client requested master to start replication from position &gt; file size&apos;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从<strong>MySQL5.6</strong>开始引入了<strong>binlog_checksum</strong>全局变量，即<strong>MySQL</strong>会将<strong>event</strong>的<strong>CRC32</strong>校验值也写入<strong>binlog</strong>，显然<strong>MariaDB</strong>在分析日志的时候不会考虑该信息，导致解析出错</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;%binlog%&apos;;</span><br><span class="line">set global binlog_checksum=NONE;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>python脚本向Mysql插入一亿条测试数据</title>
    <url>/2016/08/07/python%E8%84%9A%E6%9C%AC%E5%90%91Mysql%E6%8F%92%E5%85%A5%E4%B8%80%E4%BA%BF%E6%9D%A1%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>当我想要测试mysql的诸多索引时，需要用到大量的数据，重复的。不重复的，int类型的，varchar类型的，时间类型的等等，咋办呢？当你看到这篇博文的时候，恭喜你来对地方啦。</p>
</blockquote>
<a id="more"></a>

<h4 id="咱们废话少说，直接上代码"><a href="#咱们废话少说，直接上代码" class="headerlink" title="咱们废话少说，直接上代码"></a>咱们废话少说，直接上代码</h4><p><strong>loop_count 为批量插的次数</strong></p>
<p><strong>batch_size为每次批量查的数据量</strong></p>
<p><strong>两者通过自定义，实现想插多少插多少。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import MySQLdb</span><br><span class="line">import MySQLdb.cursors</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 批量插的次数</span><br><span class="line">loop_count = 100000</span><br><span class="line"># 每次批量查的数据量</span><br><span class="line">batch_size = 100</span><br><span class="line">success_count = 0</span><br><span class="line">fails_count = 0</span><br><span class="line"># 数据库的连接</span><br><span class="line"># 使用 SSCursor (流式游标)，避免客户端占用大量内存。(这个 cursor 实际上没有缓存下来任何数据，它不会读取所有所有到内存中，它的做法是从储存块中读取记录，并且一条一条返回给你。)</span><br><span class="line">conn = MySQLdb.connect(host=&quot;47.97.172.176&quot;,</span><br><span class="line">                       user=&quot;root&quot;,</span><br><span class="line">                       passwd=&quot;123456&quot;,</span><br><span class="line">                       db=&quot;test&quot;,</span><br><span class="line">                       port=3306,</span><br><span class="line">                       cursorclass=MySQLdb.cursors.SSCursor)</span><br><span class="line">chars = &apos;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz&apos;</span><br><span class="line">digits = &apos;0123456789&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def random_generate_string(length):</span><br><span class="line">    return &apos;&apos;.join(random.sample(chars, length))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def random_generate_number(length):</span><br><span class="line">    if length &gt; len(digits):</span><br><span class="line">        digit_list = random.sample(digits, len(digits))</span><br><span class="line">        digit_list.append(random.choice(digits))</span><br><span class="line">        return &apos;&apos;.join(digit_list)</span><br><span class="line">    return &apos;&apos;.join(random.sample(digits, length))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def random_generate_data(num):</span><br><span class="line">    c = [num]</span><br><span class="line">    phone_num_seed = 13100000000</span><br><span class="line"></span><br><span class="line">    def _random_generate_data():</span><br><span class="line">        c[0] += 1</span><br><span class="line">        return (c[0], &quot;last_name_&quot; + str(random.randrange(100000)),</span><br><span class="line">                &quot;first_name_&quot; + str(random.randrange(100000)),</span><br><span class="line">                random.choice(&apos;MF&apos;), random.randint(1, 120),</span><br><span class="line">                phone_num_seed + c[0], random_generate_string(20),</span><br><span class="line">                random_generate_string(10), time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;))</span><br><span class="line"></span><br><span class="line">    return _random_generate_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def execute_many(insert_sql, batch_data):</span><br><span class="line">    global success_count, fails_count</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    try:</span><br><span class="line">        cursor.executemany(insert_sql, batch_data)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        conn.rollback()</span><br><span class="line">        fails_count = fails_count + len(batch_data)</span><br><span class="line">        print(e)</span><br><span class="line">        raise</span><br><span class="line">    else:</span><br><span class="line">        conn.commit()</span><br><span class="line">        success_count = success_count + len(batch_data)</span><br><span class="line">        print(str(success_count) + &quot; commit&quot;)</span><br><span class="line">    finally:</span><br><span class="line">        cursor.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    # user表列的数量</span><br><span class="line">    column_count = 9</span><br><span class="line"></span><br><span class="line">    # 插入的SQL</span><br><span class="line">    insert_sql = &quot;replace into user(id, last_name, first_name, sex, age, phone, address, password, create_time) values (&quot; + &quot;,&quot;.join(</span><br><span class="line">        [&quot;%s&quot; for x in range(column_count)]) + &quot;)&quot;</span><br><span class="line">    batch_count = 0</span><br><span class="line">    begin_time = time.time()</span><br><span class="line">    for x in range(loop_count):</span><br><span class="line">        batch_count = x * batch_size</span><br><span class="line">        gen_fun = random_generate_data(batch_count)</span><br><span class="line">        batch_data = [gen_fun() for x in range(batch_size)]</span><br><span class="line">        execute_many(insert_sql, batch_data)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    total_sec = end_time - begin_time</span><br><span class="line">    qps = success_count / total_sec</span><br><span class="line">    print(&quot;总共生成数据： &quot; + str(success_count))</span><br><span class="line">    print(&quot;总共耗时(s): &quot; + str(total_sec))</span><br><span class="line">    print(&quot;QPS: &quot; + str(qps))</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line">    raise</span><br><span class="line">else:</span><br><span class="line">    pass</span><br><span class="line">finally:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p><strong>效果图</strong></p>
<p><img src="https://xuefeng.online/2018/08/08/python%E8%84%9A%E6%9C%AC%E5%90%91Mysql%E6%8F%92%E5%85%A5%E4%B8%80%E4%BA%BF%E6%9D%A1%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/1577242844(1).png" alt="效果图"></p>
<h4 id="妈妈再也不用担心我测试数据不足啦！"><a href="#妈妈再也不用担心我测试数据不足啦！" class="headerlink" title="妈妈再也不用担心我测试数据不足啦！"></a>妈妈再也不用担心我测试数据不足啦！</h4>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx负载均衡</title>
    <url>/2016/03/23/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h2 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a>nginx负载均衡</h2><ul>
<li>轮询（默认）——每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</li>
</ul>
<ul>
<li><p>weight ——指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
</li>
<li><p>ip_hash ——每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器。</p>
</li>
<li><p>backup——其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</p>
</li>
<li><p>down——表示单前的server暂时不参与负载</p>
</li>
<li><p>fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。与weight分配策略类似。</p>
</li>
</ul>
<a id="more"></a>

<p><strong>在nginx配置文件（nginx.conf）中配置</strong></p>
<p>##负载均衡配置</p>
<p>Nginx不仅可以作为一个Web服务器或反向代理服务器，还可以通过轮询、权重、ip_hash、第三方模块多种方式实现负载均衡。</p>
<p><strong>基础配置环境:所有配置负载均衡方式的基础环境一至准备3台虚拟机，并全部安装Nginx服务器</strong></p>
<p>负责均衡服务器：192.168.12.128</p>
<p>后端web1服务器: 192.168.12.129</p>
<p>后端web2服务器: 192.168.12.130</p>
<p>后端备份服务器:   192.168.12.131</p>
<p>##配置一般轮询负载均衡</p>
<p>配置nginx.conf文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  test.ng.test;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_pass http://web_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">upstream web_server &#123;</span><br><span class="line">   server 192.168.12.129;</span><br><span class="line">   server 192.168.12.130;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##加权轮询负载均衡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  test.ng.test;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_pass http://web_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">upstream web_server &#123;</span><br><span class="line">    server 192.168.12.129 weight=1 max_fails=1 fail_timeout=2;</span><br><span class="line">    server 192.168.12.130 weight=8 max_fails=2 fail_timeout=2;</span><br><span class="line">    server 192.168.12.131 backup;  </span><br><span class="line">    #当所服有务器岩机了，会自动启用预留的备份服务器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 参数说明：</p>
<p>weight  参数值越高则被分配到的概率越大</p>
<p>max_fails  允许请求失败的次数，默认为1</p>
<p>fail_timeout 在经历了max_fails次失败后，暂停服务的时间</p>
<p>backup 预留的备份机器</p>
<p>down  表示当前的server暂时不参与负载均衡</p>
<p>##ip_hash负载均衡</p>
<p>ip_hash方式的负载均衡，是将每个请求按照访问IP的hash结果分配，这样可以使来自同一个IP的客户端用户固定访问一台Web服务器，有效地解决了动态网页存在Session共享问题。</p>
<p>这种方式，无法保证负载均衡，建议少使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  test.ng.test;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_pass http://web_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">upstream web_server &#123;</span><br><span class="line">   ip_hash; </span><br><span class="line">   server 192.168.12.129 ;</span><br><span class="line">   server 192.168.12.130 ;    </span><br><span class="line">   server 192.168.12.131 down;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>down 在负载均衡时，会忽略服务器的分配；</p>
<p>ip_hash方式不能使用weight和backup设置。</p>
<p>##利用第三方模块</p>
<p>按照Web服务器的响应时间实现负载均衡，响应时间短的优先分配。</p>
<p><strong>需要重新编译安装nginx:</strong>（配置fair方式的负载均衡）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  	listen 80;</span><br><span class="line">    server_name test.ng.test;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_pass http://web_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">upstream web_server &#123;</span><br><span class="line">     server 192.168.12.129;</span><br><span class="line">     server 192.168.12.130;</span><br><span class="line">     server 192.168.12.131;</span><br><span class="line">     fair;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下载地址：<a href="https://github.com/gnosek/nginx-upstream-fair" target="_blank" rel="noopener">https://github.com/gnosek/nginx-upstream-fair</a> </p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Django邮件发送及华丽呼哨的邮件格式</title>
    <url>/2015/11/12/Django%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%8F%8A%E5%8D%8E%E4%B8%BD%E5%91%BC%E5%93%A8%E7%9A%84%E9%82%AE%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><blockquote>
<p><code>django</code>中内置了许多方法可以使开发者方便的进行邮件发送</p>
</blockquote><a id="more"></a>
<h3 id="邮件配置"><a href="#邮件配置" class="headerlink" title="邮件配置"></a>邮件配置</h3><blockquote>
<p>发送邮件，首先需要在项目的<code>settings.py</code>文件下配置邮件服务器连接等信息</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EMAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址</span></span><br><span class="line">EMAIL_PORT = <span class="number">465</span> <span class="comment"># 邮件服务器端口 </span></span><br><span class="line">EMAIL_HOST_USER = <span class="string">'account@qq.com'</span> <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">'password'</span>  <span class="comment"># 登陆邮件服务器的密码</span></span><br><span class="line">DEFAULT_FROM_EMAIL = EMAIL_HOST_USER <span class="comment"># 邮件的发送者</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：<code>EMAIL_HOST_PASSWORD</code>所设置的登陆邮件服务器的密码为邮件客户端后台所设置的第三方客户端登陆密码，这个值并非直接账号密码</p>
<p>如：<code>QQ</code>邮箱的该值密码在网页版<code>QQ</code>邮件客户端的设置<code>-&gt;</code>帐户<code>-&gt;</code>开启<code>POP3/SMTP服务|IMAP/SMTP服务</code></p>
</blockquote>
<h3 id="发送文本邮件"><a href="#发送文本邮件" class="headerlink" title="发送文本邮件"></a>发送文本邮件</h3><blockquote>
<p>发送普通邮件可以使用<code>django.core.mail</code>模块下的<code>send_mail</code>函数进行</p>
</blockquote>
<ul>
<li><p><code>send_mail(subject, message, from_email, recipient_list, fail_silently=False, html_message=None)</code></p>
<blockquote>
<p>将邮件发送至<code>recipient_list</code>中的每一个收件人处</p>
</blockquote>
<blockquote>
<p><code>subject</code>：发送邮件标题</p>
<p><code>message</code>：发送邮件正文</p>
<p><code>from_email</code>：发件人邮箱地址</p>
<p><code>recipient_list</code>：一个字符串列表，每一个数据为接收者的邮箱地址</p>
<p><code>html_message</code>：如果指定该值，则发送的内容类型为<code>text/html</code>为一个<code>html</code>邮件内容</p>
</blockquote>
</li>
<li><p>发送普通邮件视图函数</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'邮件测试'</span></span><br><span class="line">    message = <span class="string">'&lt;a href="http://www.python.org"&gt;学习Python，我很快乐&lt;/a&gt;'</span></span><br><span class="line">    send_mail(</span><br><span class="line">        subject = subject,</span><br><span class="line">        message = message,</span><br><span class="line">        from_email = <span class="string">'from@qq.com'</span>,</span><br><span class="line">        recipient_list = [<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="发送HTML邮件"><a href="#发送HTML邮件" class="headerlink" title="发送HTML邮件"></a>发送HTML邮件</h3><blockquote>
<p>发送这里的邮件内容为一个<code>HTML</code>的<code>a</code>标签，但是真正接收者接到该邮件时，<code>a</code>标签并不会解释称为真正的<code>a</code>标签，只是一个普通的字符串，这是因为当前发送邮件的类型为<code>text/plain</code>，可以使用<code>html_message</code>参数进行<code>HTML</code>内容的发送</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span>    </span><br><span class="line">    subject = <span class="string">'邮件测试'</span></span><br><span class="line">    message = <span class="string">'&lt;a href="http://www.python.org"&gt;学习Python，我很快乐&lt;/a&gt;'</span></span><br><span class="line">    send_mail(</span><br><span class="line">        subject = subject,</span><br><span class="line">        message = <span class="string">''</span>, <span class="comment"># 该参数为必须参数，必须填写</span></span><br><span class="line">        html_message = message,</span><br><span class="line">        from_email = <span class="string">'from@qq.com'</span>,</span><br><span class="line">        recipient_list =[<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发送<code>html</code>格式邮件还可以使用<code>django.core.mail</code>模块下的<code>EmailMultiAlternatives</code>类进行邮件体的构造，然后进行邮件发送</p>
</blockquote>
<ul>
<li><p><code>EmailMultiAlternatives(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None)</code></p>
<blockquote>
<p><code>subject</code>：邮件标题</p>
<p><code>body</code>：邮件内容</p>
<p><code>from_email</code>：邮件发送者</p>
<p><code>to</code>：邮件接收人列表</p>
</blockquote>
</li>
<li><p><code>EmailMultiAlternatives.attach_alternative(content, mimetype)</code></p>
<blockquote>
<p>向<code>EmailMultiAlternatives</code>实例中添加<code>mimetype</code>支持的邮件内容</p>
<p><code>content</code>：添加的邮件内容</p>
<p><code>mimetype</code>：添加内容的<code>mime</code>类型</p>
</blockquote>
</li>
<li><p><code>EmailMultiAlternatives.send()</code></p>
<blockquote>
<p>发送邮件</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMultiAlternatives</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'邮件测试'</span></span><br><span class="line">    text_message = <span class="string">'学习Python，我很快乐'</span></span><br><span class="line">    html_message = <span class="string">'&lt;a href="http://www.python.org"&gt;学习Python，我很快乐&lt;/a&gt;'</span></span><br><span class="line">    email = EmailMultiAlternatives(</span><br><span class="line">        subject = subject,</span><br><span class="line">        body = text_message,</span><br><span class="line">        from_email = <span class="string">'1747266529@qq.com'</span>,</span><br><span class="line">        to = [<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    email.attach_alternative(html_message,<span class="string">'text/html'</span>) <span class="comment"># 添加HTML邮件部分</span></span><br><span class="line">    email.send() <span class="comment"># 发送邮件</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="发送富文本邮件"><a href="#发送富文本邮件" class="headerlink" title="发送富文本邮件"></a>发送富文本邮件</h3><blockquote>
<p>经常需要我们在邮件中加入图片等静态资源</p>
<p>需要用到<code>python</code>中<code>email.mime.image</code>模块下的<code>MIMEImage</code>类进行图片内容的构造</p>
<p>这里发送邮件使用<code>EmailMessage</code>类，来自于<code>django.core.mail</code>模块下</p>
<p>并在使用对应该类实例的<code>attach</code>添加图片资源数据</p>
<p>最后使用实例的<code>send</code>函数发送邮件</p>
</blockquote>
<ul>
<li><p><code>EmailMessage(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None)</code></p>
<blockquote>
<p>``subject`：邮件标题</p>
<p><code>body</code>：邮件内容</p>
<p><code>from_email</code>：邮件发送者</p>
<p><code>to</code>：邮件接收人列表</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sendmailpro.settings <span class="keyword">import</span> STATICFILES_DIRS</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMessage</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'图片邮件测试'</span></span><br><span class="line">    file_1 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/1.png'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(file_1, <span class="string">'rb'</span>) <span class="keyword">as</span> fp: </span><br><span class="line">        <span class="comment"># 打开第一张图片</span></span><br><span class="line">        image_1 = MIMEImage(fp.read())</span><br><span class="line">        </span><br><span class="line">    file_2 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/2.png'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(file_2, <span class="string">'rb'</span>) <span class="keyword">as</span> fp: </span><br><span class="line">        <span class="comment"># 打开第二张图片</span></span><br><span class="line">        image_2 = MIMEImage(fp.read())</span><br><span class="line">        </span><br><span class="line">    body = <span class="string">"&lt;img src='cid:first_id'&gt;&lt;br&gt;&lt;img src='cid:sec_id'&gt;"</span></span><br><span class="line">    <span class="comment"># 发送邮件主体内容</span></span><br><span class="line">    </span><br><span class="line">	image_1.add_header(<span class="string">'Content-ID'</span>,<span class="string">'&lt;%s&gt;'</span> % <span class="string">'first_id'</span>) </span><br><span class="line">    <span class="comment"># 通过 CID 对称图片在邮件内容中的位置</span></span><br><span class="line">    image_2.add_header(<span class="string">'Content-ID'</span>,<span class="string">'&lt;%s&gt;'</span> % <span class="string">'sec_id'</span>)</span><br><span class="line">    </span><br><span class="line">    message = EmailMessage( <span class="comment"># 构建发送的邮件主体</span></span><br><span class="line">                subject=subject,</span><br><span class="line">                body=body,</span><br><span class="line">                from_email=<span class="string">'from@qq.com'</span>,</span><br><span class="line">                to=[<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">            )</span><br><span class="line">    message.content_subtype = <span class="string">'html'</span></span><br><span class="line">    message.attach(image_1) <span class="comment"># 添加两张图片</span></span><br><span class="line">    message.attach(image_2)</span><br><span class="line">    message.send() <span class="comment"># 发送邮件</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="发送附件邮件"><a href="#发送附件邮件" class="headerlink" title="发送附件邮件"></a>发送附件邮件</h3><blockquote>
<p>发送附件，也可以使用<code>django.core.mail</code>模块下的<code>EmailMessage</code>类进行附件邮件体构造</p>
<p>通过<code>EmailMessage</code>实例的<code>attach|attach_file</code>两个函数在邮件主体中添加附件内容</p>
<p><code>attach_file</code>添加邮件附件直接加入路径即可，但是<code>attach</code>添加附件内容需要提供附件内容</p>
</blockquote>
<ul>
<li><p><code>attach(filename=None, content=None, mimetype=None)</code></p>
<blockquote>
<p>添加附件内容</p>
</blockquote>
<blockquote>
<p><code>filename</code>：附件文件名称</p>
<p><code>content</code>：附件内容</p>
<p><code>mimetype</code>：附件的<code>MIME</code>类型</p>
</blockquote>
</li>
<li><p><code>attach_file(path, mimetype=None)</code></p>
<blockquote>
<p>直接通过路径添加附件</p>
</blockquote>
<blockquote>
<p><code>path</code>：附件路径</p>
<p><code>mimetype</code>：附件的<code>MIME</code>类型</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sendmailpro.settings <span class="keyword">import</span> STATICFILES_DIRS</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMessage</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'附件邮件测试'</span></span><br><span class="line">    email = EmailMessage(</span><br><span class="line">        subject=subject,</span><br><span class="line">        body=<span class="string">'这是一封具有图片附件的邮件'</span>,</span><br><span class="line">        from_email=<span class="string">'from@qq.com'</span>,</span><br><span class="line">        to=[<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    file_1 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/1.png'</span>)</span><br><span class="line">    image_1 = open(file_1,<span class="string">'rb'</span>).read()</span><br><span class="line">    email.attach(<span class="string">'1.png'</span>,image_1,<span class="string">'image/png'</span>) <span class="comment"># 使用attach实例函数添加附件内容</span></span><br><span class="line"></span><br><span class="line">    file_2 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/2.png'</span>)</span><br><span class="line">    email.attach_file(file_2,mimetype=<span class="string">'image/png'</span>) <span class="comment"># 使用attach_file实例函数添加附件路径</span></span><br><span class="line"></span><br><span class="line">    email.send()</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
</search>
