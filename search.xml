<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2019/09/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>HayStack全文检索在Django中的应用</title>
    <url>/2018/10/16/HayStack%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%9C%A8Django%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><p><a href="https://django-haystack.readthedocs.io/en/v2.4.1/tutorial.html" target="_blank" rel="noopener">官方文档</a></p><blockquote>
<p>全文检索就是针对所有内容进行动态匹配搜索的概念</p>
<p>针对特定的关键词进行<strong>建立索引</strong>并<strong>精确匹配</strong>取出搜索结果，并且达到性能优化的目的</p>
</blockquote><a id="more"></a>

<ul>
<li>为啥要有全文检索</li>
</ul>
<blockquote>
<p>最常见的全文检索就是我们在数据库中进行的模糊查询</p>
<p>但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低</p>
<p>常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作</p>
<p>如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项</p>
</blockquote>
<ul>
<li><code>django</code>使用啥进行全文检索</li>
</ul>
<blockquote>
<p><code>Python</code>提供了各种模块进行全文检索，最常见的是<code>haystack</code>模块</p>
<p>该模块设计为支持<code>whoosh</code>、<code>solr</code>、<code>Xapian</code>、<code>Elasticsearch</code>四种全文检索引擎后端</p>
<p>使用<code>haystack</code>模块，不用更改代码，直接切换引擎，可以极大的减少代码量</p>
<p><code>haystack</code>属于一种<strong>全文检索</strong>的框架</p>
</blockquote>
<hr>
<ul>
<li><strong>whoosh</strong></li>
</ul>
<blockquote>
<p>纯<code>Python</code>编写的全文搜索引擎，是目前最快的<code>python</code>所编写的检索引擎，虽然性能比不上<code>solr</code>、<code>Xapian</code>、<code>Elasticsearch</code>等；但是无二进制包，程序不会莫名其妙的崩溃，对于小型的站点，<code>whoosh</code>已经足够使用</p>
</blockquote>
<ul>
<li><strong>solr</strong></li>
</ul>
<blockquote>
<p><code>Solr</code>是一个高性能，采用<code>Java5</code>开发，基于<code>Lucene</code>的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎</p>
<p><code>Lucene</code>：不是一个完整的<strong>全文检索引擎</strong>，是一个全文检索引擎的<strong>架构</strong>，提供了完整的查询引擎和索引引擎，<code>Lucene</code>的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能</p>
</blockquote>
<ul>
<li><strong>Xapian</strong></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Xapian`是一个用`C++`编写的全文检索程序，他的作用类似于`Java`的`lucene</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>Elasticsearch</strong></li>
</ul>
<blockquote>
<p><code>ElasticSearch</code>是一个基于<code>Lucene</code>的搜索服务器它提供了一个分布式多用户能力的全文搜索引擎，基于<code>RESTful web</code>接口</p>
<p><code>Elasticsearch</code>是用Java开发的，并作为<code>Apache</code>许可条款下的开放源码发布，是当前流行的企业级搜索引擎。该引擎常设计用于云计算中；能够达到<strong>实时搜索</strong>，<strong>稳定</strong>，<strong>可靠</strong>，<strong>快速</strong>，<strong>安装</strong>使用方便</p>
</blockquote>
<h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><blockquote>
<p><code>whoosh</code>作为一个全文搜索引擎模块</p>
<p>分词功能和检索功能已经非常强大，但是针对中文的处理还是比较欠缺</p>
<p>可以通过<code>Jieba</code>模块重写分词操作，支持<code>whoosh</code>对中文的强大操作</p>
</blockquote>
<ul>
<li>安装中文分词模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install jieba</span><br></pre></td></tr></table></figure>

<ul>
<li><p>除了<code>jieba</code>分词，现在还有很多付费的中文分词模块</p>
<blockquote>
<p><a href="http://ictclas.nlpir.org/nlpir/" target="_blank" rel="noopener">中科院计算所NLPIR</a></p>
<p><a href="https://github.com/NLPchina/ansj_seg" target="_blank" rel="noopener"><code>ansj</code>分词器</a></p>
<p><a href="https://github.com/HIT-SCIR/ltp" target="_blank" rel="noopener">哈工大的<code>LTP</code></a></p>
<p><a href="https://github.com/thunlp/THULAC" target="_blank" rel="noopener">清华大学<code>THULAC</code></a></p>
<p><a href="https://nlp.stanford.edu/software/segmenter.shtml" target="_blank" rel="noopener">斯坦福分词器</a></p>
<p><a href="https://github.com/hankcs/HanLP" target="_blank" rel="noopener"><code>Hanlp</code>分词器</a></p>
<p><a href="https://github.com/yanyiwu/cppjieba" target="_blank" rel="noopener">结巴分词</a></p>
<p><a href="https://github.com/koth/kcws" target="_blank" rel="noopener"><code>KCWS</code>分词器(字嵌入<code>+Bi-LSTM+CRF</code>)</a></p>
<p><a href="https://github.com/frcchang/zpar/releases" target="_blank" rel="noopener"><code>ZPar</code></a></p>
<p><a href="https://github.com/wks/ik-analyzer" target="_blank" rel="noopener"><code>IKAnalyzer</code></a></p>
</blockquote>
</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>首先安装<code>HayStack</code>框架以及<code>whoosh</code>搜索引擎</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django-haystack</span><br><span class="line">pip install whoosh</span><br></pre></td></tr></table></figure>

<h3 id="settings配置"><a href="#settings配置" class="headerlink" title="settings配置"></a>settings配置</h3><ul>
<li>添加<code>haystack</code>应用到项目的<code>settings</code>文件下的<code>app</code>部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &apos;django.contrib.admin&apos;,</span><br><span class="line">	...</span><br><span class="line">    &apos;haystack&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>添加搜索引擎，这里使用<code>whoosh</code>引擎</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HAYSTACK_CONNECTIONS = &#123;</span><br><span class="line">    &apos;default&apos;: &#123;</span><br><span class="line">        &apos;ENGINE&apos;: &apos;haystack.backends.whoosh_cn_backend.WhooshEngine&apos;,</span><br><span class="line">        &apos;PATH&apos;: os.path.join(BASE_DIR, &apos;whoosh_index&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#这里使用django的信号机制，在数据表发生改动时自动更新whoosh的查询索引</span><br><span class="line">HAYSTACK_SIGNAL_PROCESSOR = &apos;haystack.signals.RealtimeSignalProcessor&apos;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里要注意的是，我们使用的引擎为<code>whoosh_cn_backend</code></p>
<p>本身的<code>whoosh</code>引擎名为：<code>whoosh_backend</code></p>
<p><code>whoosh_cn_backend</code>将在接下来我们对安装目录下的引擎文件复制修改得来</p>
</blockquote>
<ul>
<li>在项目的路由文件下配置查询的路由映射</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.urls import include,re_path</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;admin/&apos;, admin.site.urls),</span><br><span class="line">    re_path(&apos;^search/&apos;,include(&apos;haystack.urls&apos;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当查询条件被提交时，会跳转至<code>search</code>路由</p>
<p>并且查询条件会作为<code>get</code>请求时的连接参数传入，参数<code>key</code>值为<code>q</code></p>
</blockquote>
<h3 id="创建索引文件"><a href="#创建索引文件" class="headerlink" title="创建索引文件"></a>创建索引文件</h3><ul>
<li>接下来，在需要被搜索的<code>app</code>下建立<code>search_indexes.py</code>文件，该文件名不许变更</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#app.models.py</span><br><span class="line">class User(models.Model):</span><br><span class="line">    # 用户表</span><br><span class="line">    name = models.CharField(</span><br><span class="line">        max_length=50,</span><br><span class="line">        verbose_name=&apos;昵称&apos;</span><br><span class="line">        )</span><br><span class="line">    account = models.CharField(max_length=50,verbose_name=&apos;账号&apos;,unique=True)</span><br><span class="line">    passwd = models.CharField(max_length=50,verbose_name=&apos;密码&apos;)</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line">#app.search_indexes.py</span><br><span class="line">from haystack import indexes</span><br><span class="line">from . import models</span><br><span class="line"></span><br><span class="line">class UserIndex(indexes.SearchIndex, indexes.Indexable):</span><br><span class="line">    text = indexes.CharField(document=True, use_template=True)</span><br><span class="line"></span><br><span class="line">    def get_model(self):</span><br><span class="line">        return models.User # 当前模型文件下需要被检索的模型类</span><br><span class="line"></span><br><span class="line">    def index_queryset(self, using=None):</span><br><span class="line">        return self.get_model().objects.all()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该类为索引类，类名为模型类的名称<code>+Index</code>：比如模型类为<code>People</code>,则这里类名为<code>PeopleIndex</code></p>
<p><code>get_model</code>函数用来获取当前索引类所关联的模型类，这里我们关联上面的<code>User</code> 类对象</p>
<p><code>text=indexes.CharField</code>语句指定了将模型类中的哪些字段建立索引，而<code>use_template=True</code>说明后续我们将通过一个<strong>数据模板</strong>文件来指明需要检索的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; document=True</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>为什么要创建索引：索引就像是一本书的目录，可以为读者提供更快速的导航与查找</p>
</blockquote>
<h3 id="创建模板数据文件"><a href="#创建模板数据文件" class="headerlink" title="创建模板数据文件"></a>创建模板数据文件</h3><ul>
<li>创建数据模板文件</li>
</ul>
<blockquote>
<p>数据模板文件路径：<code>templates/search/indexes/yourapp/note_text.txt</code></p>
<p>放在任何一个你的<code>Django</code>能搜索到的模板文件夹<code>template</code>下面均可，这个文件主要确定要检索的字段，为他们建立索引</p>
<p>文件名必须为要索引的类名<code>_text.txt</code>，比如这里我们检索的类名是<code>User</code>，那么对应的数据模板文件名为<code>user_text.txt</code>，文件名小写即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#template.search.indexes.people.user_text.txt</span><br><span class="line">&#123;&#123; object.name &#125;&#125;</span><br><span class="line">&#123;&#123; object.account &#125;&#125;</span><br><span class="line">&#123;&#123; object.online_time &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在数据模板文件中使用模板语法，写入需要建立索引的字段，这里我们将模型类中<code>name</code>、<code>account</code>以及<code>online_time</code>字段设置索引，当检索时会对这三个字段去做全文检索</p>
</blockquote>
<blockquote>
<p>接下来创建一个搜索结果展示页面</p>
</blockquote>
<h3 id="检索结果模板页面"><a href="#检索结果模板页面" class="headerlink" title="检索结果模板页面"></a>检索结果模板页面</h3><ul>
<li>创建检索结果展示页面</li>
</ul>
<blockquote>
<p>检索结果展示页面，需要在固定的目录路径下进行模板页面的编写</p>
<p>路径为：<code>templates/search/</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#123;% if query %&#125;</span><br><span class="line">    &lt;h3&gt;搜索结果如下：&lt;/h3&gt;</span><br><span class="line">    &#123;% for result in page.object_list %&#125;</span><br><span class="line">        &#123;&#123; result.object.name &#125;&#125;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &#123;&#123; result.object.account &#125;&#125;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &#123;&#123; result.object.online_time &#125;&#125;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        &lt;p&gt;没找到&lt;/p&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;% if page.has_previous or page.has_next %&#125;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;% if page.has_previous %&#125;</span><br><span class="line">            	&lt;a href=&quot;?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.previous_page_number &#125;&#125;&quot;&gt;</span><br><span class="line">            		上一页</span><br><span class="line">            	&lt;/a&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">            &#123;% if page.has_next %&#125;</span><br><span class="line">            	&lt;a href=&quot;?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.next_page_number &#125;&#125;&quot;&gt;</span><br><span class="line">            		下一页</span><br><span class="line">            	&lt;/a&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个模板页面中已经自带了分页功能，可以按照需求修改</p>
</blockquote>
<ul>
<li>创建检索模板页面内容</li>
</ul>
<blockquote>
<p>还需要有一个表单，提交检索信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method=&apos;get&apos; action=&quot;/search/&quot; &gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;q&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这部分检索的模板页面内容可以在你的项目中进行添加，查询方式为<code>get</code>，并且检索输入的表单框<code>name</code>属性必须为<code>q</code></p>
</blockquote>
<h3 id="中文分词配置"><a href="#中文分词配置" class="headerlink" title="中文分词配置"></a>中文分词配置</h3><ul>
<li>接下来，需要创建有关中文检索的配置文件，这里的配置文件创建为全局</li>
</ul>
<blockquote>
<p>进入到<code>python</code>的安装目录下，比如我的目录为：<code>C:\Python37\Lib\site-packages\haystack\backends</code></p>
<p>在该路径下创建名为<code>ChineseAnalyzer.py</code>的中文分词文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import jieba</span><br><span class="line">from whoosh.analysis import Tokenizer, Token</span><br><span class="line"></span><br><span class="line">class ChineseTokenizer(Tokenizer):</span><br><span class="line">    def __call__(self, value, positions=False, chars=False,</span><br><span class="line">                 keeporiginal=False, removestops=True,start_pos=0, start_char=0, mode=&apos;&apos;, **kwargs):</span><br><span class="line">        t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs)</span><br><span class="line">        seglist = jieba.cut(value, cut_all=True)</span><br><span class="line">        for w in seglist:</span><br><span class="line">            t.original = t.text = w</span><br><span class="line">            t.boost = 1.0</span><br><span class="line">            if positions:</span><br><span class="line">                t.pos = start_pos + value.find(w)</span><br><span class="line">            if chars:</span><br><span class="line">                t.startchar = start_char + value.find(w)</span><br><span class="line">                t.endchar = start_char + value.find(w) + len(w)</span><br><span class="line">            yield t</span><br><span class="line"></span><br><span class="line">def ChineseAnalyzer():</span><br><span class="line">    return ChineseTokenizer()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个文件中，定义了一个<code>ChineseAnalyzer</code>的函数，这个函数将替代搜索引擎配置文件中的分词方式</p>
</blockquote>
<ul>
<li>复制引擎文件，修改分词方式为中文</li>
</ul>
<blockquote>
<p>同样在该文件夹下<code>C:\Python37\Lib\site-packages\haystack\backends</code>，复制<code>whoosh_backend.py</code>文件，创建一个新的文件名为<code>whoosh_cn_backend.py</code>，这里复制出一份文件也是为了之后如果不需要使用中文分词，可以直接在<code>settings</code>配置文件中修改引擎为<code>&#39;ENGINE&#39;:&#39;haystack.backends.whoosh_backend.WhooshEngine&#39;,</code></p>
</blockquote>
<blockquote>
<p>修改该引擎配置文件中的：<code>analyzer=StemmingAnalyzer()</code>变为<code>analyzer=ChineseAnalyzer()</code></p>
<p>并且要记得在头部引入刚才所编写的中文分词文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#whoosh_cn_backend.py</span><br><span class="line">from .ChineseAnalyzer import ChineseAnalyzer</span><br></pre></td></tr></table></figure>

<h3 id="初始化索引"><a href="#初始化索引" class="headerlink" title="初始化索引"></a>初始化索引</h3><ul>
<li>最后，初始化索引数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py rebuild_index</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Paramiko</title>
    <url>/2018/09/15/Paramiko/</url>
    <content><![CDATA[<h2 id="Paramiko"><a href="#Paramiko" class="headerlink" title="Paramiko"></a>Paramiko</h2><blockquote>
<p><code>Paramiko</code>是<code>SSHv2</code>协议的<code>Python</code>实现，提供客户端和服务器功能</p>
<p><code>Paramiko</code>本身是一个围绕<code>SSH</code>网络概念的纯<code>Python</code>接口</p>
<p>利用<code>paramiko</code>我们可以通过<code>Python</code>方便的进行<code>ssh</code>操作</p>
</blockquote><a id="more"></a>
<hr>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; paramiko`包含两个核心组件：`SSHClient`和`SFTPClient</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="SSHClient"><a href="#SSHClient" class="headerlink" title="SSHClient"></a>SSHClient</h3><blockquote>
<p><code>SSHClient</code>的作用类似于<code>Linux</code>的<code>ssh</code>命令，是对<code>SSH</code>会话的封装</p>
<p>该类封装了传输<code>Transport</code>，通道<code>Channel</code>及<code>SFTPClient</code>建立的方法<code>open_sftp</code>，通常用于执行远程命令</p>
</blockquote>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul>
<li><code>class paramiko.client.SSHClient</code></li>
</ul>
<blockquote>
<p>创建<code>SSH</code>客户端实例</p>
</blockquote>
<ul>
<li><code>SSHClient.connect(hostname, port=22, username=None, password=None, pkey=None, key_filename=None, timeout=None, allow_agent=True, look_for_keys=True, compress=False..)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 参数解释</span><br><span class="line">- hostname：连接的目标主机</span><br><span class="line">- port=SSH_PORT：指定端口</span><br><span class="line">- username=None：验证的用户名</span><br><span class="line">- password=None：验证的用户密码</span><br><span class="line">- pkey=None：私钥方式用于身份验证</span><br><span class="line">- key_filename=None：一个文件名或文件列表，指定私钥文件</span><br><span class="line">- timeout=None：可选的tcp连接超时时间</span><br><span class="line">- allow_agent=True：是否允许连接到ssh代理，默认为True 允许</span><br><span class="line">- look_for_keys=True：是否在~/.ssh中搜索私钥文件，默认为True 允许</span><br><span class="line">- compress=False：是否打开压缩</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过验证连接远程服务端</p>
</blockquote>
<hr>
<ul>
<li><code>SSHClient.exec_command(command, bufsize=-1, timeout=None, get_pty=False, environment=None)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 参数解释</span><br><span class="line">- command：要执行的命令</span><br><span class="line">- bufsize：与Python中文件对象的同名函数解释相同，缓冲区大小</span><br><span class="line">- timeout：设置命令的超时相应事件</span><br><span class="line">- get_pty：从服务器请求一个伪终端（默认为假）</span><br><span class="line">- environment：一个当前shell环境的字典，远程命令的默认执行环境</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>command</code>参数为要执行的<code>shell</code>命令，打开一个新通道并执行请求的命令</p>
<p>该函数的返回结果为一个元组，其中包含<code>stdin</code>、<code>stdout</code>和<code>stderr</code>，也就是我们常见的标准输入，输出以及出错</p>
<p>一般来说，命令的结果我们将通过<code>stdout</code>进行获取</p>
</blockquote>
<hr>
<ul>
<li><code>SSHClient.close()</code></li>
</ul>
<blockquote>
<p>关闭<code>SSH</code>连接</p>
</blockquote>
<hr>
<ul>
<li><code>SSHClient.invoke_shell(term=’vt100’, width=80, height=24, width_pixels=0, height_pixels=0, environment=None)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 参数解释</span><br><span class="line">- term：模拟终端类型</span><br><span class="line">- width：终端长度</span><br><span class="line">- height：终端宽度</span><br><span class="line">- width_pixels：终端的像素宽度</span><br><span class="line">- height_pixels：终端的像素高度</span><br><span class="line">- environment：命令的shell环境</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>ssh</code>服务器上启动交互式<code>shell</code>会话</p>
<p>一个新的通道被打开并连接到，使用请求的终端类型和大小的伪终端，并作为返回值</p>
<p>换句通俗的话来讲，就是创建了一个实际的<code>shell</code>窗口空间进行命令交互</p>
</blockquote>
<hr>
<ul>
<li><code>SSHClient.set_missing_host_key_policy(policy)</code></li>
</ul>
<blockquote>
<p>设置连接到没有已知主机密钥的服务器时要使用的策略</p>
<p>常见使用策略为<code>paramiko.client.AutoAddPolicy</code>，其意义为自动将主机名和新主机密钥添加到本地主机密钥对象并保存</p>
</blockquote>
<h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><blockquote>
<p>以下是一个简单的通过<code>SSHClient</code>建立的通道进行命令的传输与返回结果的获取的代码！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import paramiko </span><br><span class="line"></span><br><span class="line">def connect(hostname,username,password):</span><br><span class="line">	client = paramiko.SSHClient() </span><br><span class="line">    # 初始化</span><br><span class="line">	client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    # 设置密钥策略</span><br><span class="line">	client.connect(hostname,username=username,password=password)</span><br><span class="line">    # 连接主机</span><br><span class="line">	return client</span><br><span class="line"></span><br><span class="line">def exec_cmd(client,cmd):</span><br><span class="line">	stdin,stdout,stderr = client.exec_command(cmd)</span><br><span class="line">	return stdout.read().decode(),stderr.read().decode()</span><br><span class="line">def main():</span><br><span class="line">	hostname = &apos;192.168.0.104&apos;</span><br><span class="line">	username = &apos;pi&apos;</span><br><span class="line">	password = &apos;123456&apos;</span><br><span class="line">	cmd = &apos;ps -aux&apos;</span><br><span class="line"></span><br><span class="line">	client = connect(hostname,username,password)</span><br><span class="line">	res = exec_cmd(client, cmd)</span><br><span class="line">	if res[0]:</span><br><span class="line">		print(res[0])</span><br><span class="line">	if res[1]:</span><br><span class="line">		print(&apos;[E]:\n&apos;,res[1])</span><br><span class="line">	client.close()</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码通过默认建立好的连接对象进行命令的传输以及返回结果的获取</p>
</blockquote>
<h4 id="invoke-shell"><a href="#invoke-shell" class="headerlink" title="invoke_shell"></a>invoke_shell</h4><ul>
<li>接下来使用<code>invoke_shell</code>进行虚拟终端的连接，首先初始化<code>SSH</code>通道</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SSHChannle:</span><br><span class="line">    def __init__(self, host, username, password, port=22):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">            初始化SSH通道</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        self.sh = paramiko.SSHClient()</span><br><span class="line">        self.sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        self.sh.connect(host, username=username, password=password)</span><br><span class="line">        self.channle = self.sh.invoke_shell()</span><br><span class="line">        self.cmd = &apos;&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li>思路为开启两个线程，分别负责命令的接收与命令的发送</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_ssh_recv(self):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">        接收SSH通道中发来的消息</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    while not self.channle.exit_status_ready():</span><br><span class="line">        # 如果远程进程已退出并返回退出状态，则返回true</span><br><span class="line">        time.sleep(0.1)</span><br><span class="line">        try:</span><br><span class="line">            buf = self.channle.recv(1024).decode(&apos;utf-8&apos;)</span><br><span class="line">            print(buf,end=&apos;&apos;)</span><br><span class="line">        except Exception as ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">def send_ssh_cmd(self):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">        发送命令给SSH通道</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    while not self.channle.exit_status_ready():</span><br><span class="line">        self.cmd = input()</span><br><span class="line">        try:</span><br><span class="line">            self.channle.send(self.cmd + &apos;\r&apos;)</span><br><span class="line">        except Exception as ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        # sys.stdin.flush()</span><br></pre></td></tr></table></figure>

<ul>
<li>在实例中定义<code>run</code>函数用来开启两个线程并负责线程的资源回收以及SSH通道的关闭</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def run(self):</span><br><span class="line">    ssh_recv_thread = threading.Thread(target=self.get_ssh_recv)</span><br><span class="line">    ssh_send_thread = threading.Thread(target=self.send_ssh_cmd)</span><br><span class="line">    ssh_recv_thread.start()</span><br><span class="line">    ssh_send_thread.start()</span><br><span class="line"></span><br><span class="line">    ssh_recv_thread.join()</span><br><span class="line">    ssh_send_thread.join()</span><br><span class="line"></span><br><span class="line">    self.sh.close()  # 关闭通道</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>win</code>下的<code>CMD</code>中查看效果，其中的乱码格式其实为连接后命令传输的特殊标记格式，可以在后面结合前端中类似<code>xterm.js</code>等插件查看到实际花里胡哨的效果</li>
</ul>
<p><a href="https://lienze.tech/blog/images/invoke_shell.gif" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/invoke_shell.gif" alt="invoke_shell"></a></p>
<h3 id="SFTPClient"><a href="#SFTPClient" class="headerlink" title="SFTPClient"></a>SFTPClient</h3><blockquote>
<p><code>SFTPClient</code>的作用类似与<code>Linux</code>的<code>sftp</code>命令，是对<code>SFTP</code>客户端的封装</p>
<p>用以实现远程文件操作，如文件上传、下载、修改文件权限等操作</p>
</blockquote>
<h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><ul>
<li>官方文档</li>
</ul>
<blockquote>
<p>docs.paramiko.org/en/2.4/api/sftp.html</p>
</blockquote>
<ul>
<li><code>sftp=paramiko.SFTPClient.from_transport(t,window_size=None,max_packet_size=None)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 参数解释</span><br><span class="line">- t：该参数可以通过paramiko.Transport( (ip,port ))，创建一个已通过验证的传输通道，参数为IP和端口的二元组</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据参数<code>t</code>指定的已验证传输通道进行<code>SFTP</code>客户端的创建</p>
</blockquote>
<ul>
<li><code>sftp.put(localpath, remotepath, callback=None, confirm=True)</code></li>
</ul>
<blockquote>
<p>上传本地路径为<code>localpath</code>的文件到目标主机<code>remotepath</code>处</p>
</blockquote>
<ul>
<li><code>sftp.get(remotepath, localpath, callback=None)</code></li>
</ul>
<blockquote>
<p>下载远程路径为<code>remotepath</code>路径的的文件到本地主机<code>localpath</code>处</p>
</blockquote>
<ul>
<li><code>open(filename, mode=’r’, bufsize=-1)</code></li>
</ul>
<blockquote>
<p>打开位于远程主机上的文件，与<code>open</code>函数类似，返回文件对象</p>
</blockquote>
<ul>
<li><code>listdir(path=&#39;.&#39;)</code></li>
</ul>
<blockquote>
<p>返回给定路径下文件及目录的列表，默认路径为当前工作目录</p>
</blockquote>
<ul>
<li><code>chdir(path=None)</code></li>
</ul>
<blockquote>
<p>修改当前<code>SFTP</code>连接会话的工作目录</p>
</blockquote>
<ul>
<li><code>lstat(path)</code></li>
</ul>
<blockquote>
<p>检索当前<code>path</code>所指向的文件信息</p>
</blockquote>
<ul>
<li><code>mkdir(path,mode=511)</code></li>
</ul>
<blockquote>
<p>根据<code>path</code>在目标主机创建默认权限为<code>511</code>的目录</p>
</blockquote>
<ul>
<li><code>rmdir(path)</code></li>
</ul>
<blockquote>
<p>删除给定<code>path</code>所指向的目录</p>
</blockquote>
<ul>
<li><code>remove(path)</code></li>
</ul>
<blockquote>
<p>删除给定<code>path</code>所指向的文件</p>
</blockquote>
<h4 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h4><blockquote>
<p>以下是一个比较简陋的关于<code>SFTPClient</code>的测试代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import paramiko</span><br><span class="line">def connecnt(hostname,username,password): #创建连接对象</span><br><span class="line">    client = paramiko.Transport( (hostname,22))</span><br><span class="line">    try:</span><br><span class="line">        client.connect(username=username,password=password)</span><br><span class="line">    except paramiko.SSHException:</span><br><span class="line">        return None</span><br><span class="line">    sftp_client = paramiko.SFTPClient.from_transport(client)</span><br><span class="line">    return sftp_client</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    hostname = &apos;192.168.0.104&apos;</span><br><span class="line">    username = &apos;pi&apos;</span><br><span class="line">    password = &apos;123456&apos;</span><br><span class="line">    sftp_client = connecnt(hostname,username,password)</span><br><span class="line">    remotefile_path = &apos;/home/pi/test&apos; # 目标主机文件路径</span><br><span class="line">    localfile_path = &apos;/home/test&apos; # 本地主机文件路径</span><br><span class="line"></span><br><span class="line">    sftp_client.put(localfile_path, remotefile_path) #上传本地test文件到远程</span><br><span class="line">    sftp_client.get(remotefile_path, localfile_path) #下载远程test文件到本地</span><br><span class="line">    print(sftp_client.listdir())</span><br><span class="line">    print(&apos;--------------------&apos;)</span><br><span class="line">    print(sftp_client.lstat(remotefile_path))</span><br><span class="line">    print(&apos;--------------------&apos;)</span><br><span class="line">    with sftp_client.open(remotefile_path) as fp:</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux批量处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript</title>
    <url>/2017/09/15/javascript/</url>
    <content><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><blockquote>
<p><code>JavaScript</code>是运行在浏览器端的脚本语言，<code>JavaScript</code>主要解决的是前端与用户交互的问题</p>
<p>是一种动态性、弱类型的语言；</p>
<p>他的解释器就在我们的浏览器中，是浏览器的一部分</p>
<p>这门语言对<strong>大小写敏感</strong>，并会忽略多余的空格，可以使用<code>\</code>进行代码换行，注释使用<code>//</code>或<code>/**/</code></p>
</blockquote><a id="more"></a>
<ul>
<li>主要由三部分组成<ul>
<li><code>ECMAScript</code>：语言的语法和基本对象</li>
<li>文档对象模型<code>Dom(Document Object Model)</code>：处理网页内容的方法和接口</li>
<li>浏览器对象模型<code>Bom(BrowserObjectModel)</code>：与浏览器进行交互的方法和接口</li>
</ul>
</li>
<li>前端三大部<ul>
<li><code>HTML</code>：页面的内容、结构</li>
<li><code>CSS</code>：页面的表现形式、<strong>部分动画</strong></li>
<li><code>JavaScript</code>：页面的行为、交互、<strong>功能</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="JavaScript引入"><a href="#JavaScript引入" class="headerlink" title="JavaScript引入"></a>JavaScript引入</h3><ul>
<li>行间事件：为某一个具体的元素标签赋予<code>js</code>内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert(&apos;点我&apos;);&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>嵌入引入：在文档页面通过<code>Script</code>标签嵌入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;&lt;/title&gt;</span><br><span class="line">	&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">		alert(&quot;ok!&quot;);</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>外部引入：定义单独<code>js</code>文件，通过<code>script</code>标签进行引入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/main.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>alert</code>函数用来展示一个提示框</p>
</blockquote>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 1</span><br><span class="line">var y = &quot;2&quot;</span><br><span class="line">var z = 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义变量需要使用关键字：<code>var</code></p>
<ul>
<li>同时定义多个变量可以使用 <strong>，</strong> 隔开</li>
</ul>
</li>
<li><p><strong>注意</strong>：<code>javascript</code>变量均为对象，每当声明一个变量，就相当于创建了一个对象</p>
</li>
<li><p>命名规则：</p>
<ol>
<li>区分大小写</li>
<li>首字符为<strong>字母</strong>、<strong>数字</strong>、<strong>下划线</strong><code>_</code>、或<strong>美元符号</strong><code>$</code></li>
<li>其他字符可以为<strong>字母</strong>、<strong>数字</strong>、<strong>下划线</strong>、<strong>美元符号</strong></li>
</ol>
</li>
<li><p>调试程序的方法：</p>
<ul>
<li><code>alert</code>：弹框</li>
<li><code>console.log()</code>：浏览器控制台</li>
<li><code>document.title()</code>：页面标题</li>
</ul>
</li>
</ul>
<hr>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li><code>Number</code>：<strong>数字类型</strong>，可以带小数点，也可以不带</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 1.5;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>String</code>：<strong>字符串类型</strong>，可以使用<strong>单引号</strong>或<strong>双引号</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = &quot;abc&quot;;</span><br><span class="line">var b = &quot;aaaa&quot; + 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Boolean</code>：<strong>布尔类型</strong>，只能是<code>true</code>|<code>false</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = true;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>undefined</code>：<strong>未定义类型</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>null</code>：<strong>空对象类型</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = null;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看变量数据类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;abc&quot;;</span><br><span class="line">alert(typeof x)</span><br></pre></td></tr></table></figure>

<ul>
<li>匈牙利命名规则：<ul>
<li>对象 <code>o</code> (<code>Object</code>)：<code>oPerson</code></li>
<li>数组 <code>a</code> (<code>Array</code>)：<code>aUsers</code></li>
<li>字符串 <code>s</code> (<code>String</code>)：<code>sAccount</code></li>
<li>整数 <code>i</code> (<code>Integer</code>)：<code>iScore</code></li>
<li>布尔值 <code>b</code> (<code>Boolean</code>)：<code>bIsLogin</code></li>
<li>浮点数 <code>f</code> (<code>Float</code>)：<code>fPrice</code></li>
<li>函数 <code>f</code> (<code>Function</code>)：<code>fEats</code></li>
<li>正则 <code>re</code> (<code>RegExp</code>)：<code>reIDCard</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>转换为字符串：<code>toString</code>，支持<code>Boolean</code>、<code>Number</code>、<code>String</code>三种主要类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var y = &quot;abc&quot;;</span><br><span class="line">var z = true;</span><br><span class="line">alert(x.toString()) // &quot;1&quot;</span><br><span class="line">alert(y.toString()) // &quot;abc&quot;</span><br><span class="line">alert(z.toString()) // &quot;true&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>转换为数字：<strong>parseInt</strong>、<strong>parseFloat</strong>，将只含有数字的字符串变为整形或浮点型，其他类型返回<code>NaN</code>()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;123&quot;</span><br><span class="line">var y = &quot;123.01&quot;</span><br><span class="line">var z = &quot;123aa&quot;</span><br><span class="line">alert(parseInt(x)) // 123</span><br><span class="line">alert(parseFloat(x)) // 123</span><br><span class="line">alert(parseInt(y)) // 123</span><br><span class="line">alert(parseFloat(y)) // 123.01</span><br><span class="line">alert(parseInt(z)) // 123</span><br><span class="line">alert(parseFloat(z)) // 123</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：<code>parseFloat</code>转换的包含浮点数的字符串应该是十进制</li>
</ul>
<blockquote>
<p>八进制或十六进制，该方法会忽略前导<code>0</code></p>
<p>八进制数字<code>020</code>会被解析为<code>20</code></p>
<p>十六进制数字<code>0xFF</code>，会返回<code>Nan</code>，因为x符号不是有效字符</p>
</blockquote>
<hr>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul>
<li><code>Boolean()</code>：当要转换的值是至少有一个字符的字符串</li>
</ul>
<blockquote>
<p>非<code>0</code>数字或对象时，<code>Boolean()</code>函数将返回<code>true</code></p>
<p>如果该值是空字符串、数字<code>0</code>、<code>undefined</code>或<code>null</code>，它将返回<code>false</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(Boolean(0)) // false</span><br><span class="line">alert(Boolean(1)) // true</span><br><span class="line">alert(Boolean(&quot;1&quot;)) // true</span><br><span class="line">alert(Boolean(&quot;1a&quot;)) // true</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Number()</code>：换与<code>parseInt()</code>和<code>parseFloat()</code>方法的处理方式相似，只是它转换的是整个值，而不是部分值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(Number(false)) // 0</span><br><span class="line">alert(Number(true)) // 1</span><br><span class="line">alert(Number(undefined)) // NaN</span><br><span class="line">alert(Number(null)) // 0</span><br><span class="line">alert(Number(&quot;1.2&quot;)) // 1.2</span><br><span class="line">alert(Number(&quot;12&quot;)) // 12</span><br><span class="line">alert(Number(&quot;1.2.3&quot;)) // NaN</span><br><span class="line">alert(Number(new object())) // NaN</span><br><span class="line">alert(Number(50)) // 50</span><br></pre></td></tr></table></figure>

<ul>
<li><code>String()</code>：可把任何值转换成字符串</li>
<li><strong>注意</strong>：强制转换成字符串和调用<code>toString()</code>方法的唯一不同之处在于，对<code>null</code>和<code>undefined</code>值强制类型转换可以生成字符串而不引发错误</li>
</ul>
<hr>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul>
<li><code>Array</code>：数组，索引从<code>0</code>开始</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var people = [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;];</span><br><span class="line">var people = new Array(&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;);</span><br><span class="line">var people = new Array();</span><br><span class="line">people[0] = &quot;张三&quot;</span><br><span class="line">people[1] = &quot;李四&quot;</span><br><span class="line">people[2] = &quot;王五&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Object</code>：对象，就像是字典，定义时<code>key</code>值不需要设置类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;张三&quot;,</span><br><span class="line">    age: 18,</span><br><span class="line">    sex: &quot;male&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">/*对象有两种访问方式：*/</span><br><span class="line">person[&quot;name&quot;]</span><br><span class="line">person.name</span><br><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;张三&quot;;</span><br><span class="line">person.age = 17;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>函数语法：包裹在<strong>花括号</strong>中的代码块，前面使用了关键词<code>function</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&quot;func()&quot;&gt;点击这里&lt;/button&gt;</span><br><span class="line">function func(arg1,arg2,...) &#123;</span><br><span class="line">    alert(&quot;函数被执行&quot;)</span><br><span class="line">    // 执行代码</span><br><span class="line">    return 1; // return是可选的，并且可以不写返回值，单纯只做函数终止</span><br><span class="line">&#125;</span><br><span class="line">// 函数名 func</span><br><span class="line">// 参数 arg1,arg2,...</span><br><span class="line">// 返回值 return 1</span><br><span class="line">func() // 函数执行</span><br></pre></td></tr></table></figure>

<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul>
<li><strong>局部变量</strong></li>
</ul>
<blockquote>
<p>在<code>JavaScript</code>函数内部声明的变量（使用<code>var</code>）是<strong>局部</strong>变量，</p>
<p>只能在函数内部访问它</p>
<p>该变量的作用域是局部的</p>
<p><strong>生命周期</strong>：局部变量会在函数运行以后被删除 (生命期从它们被声明的时间开始)</p>
</blockquote>
<ul>
<li><strong>全局变量</strong></li>
</ul>
<blockquote>
<p>在函数外声明的变量是<strong>全局</strong>变量</p>
<p>网页上的所有脚本和函数都能访问它</p>
<p><strong>生命周期</strong>：全局变量会在页面关闭后被删除 (生命期从它们被声明的时间开始)</p>
</blockquote>
<ul>
<li>局部变量如果希望变为全局变量、可以使用<code>windows.var =</code>的形式赋予给当前窗口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">window.x = x;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func(x,y)&#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">var res = func(1,2)</span><br><span class="line">alert(res)</span><br></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JavaScript</span><br></pre></td></tr></table></figure>

<p>函数解析过程：</p>
<ol>
<li><strong>预编译</strong>：<code>function</code>函数提前，并将<code>var</code>定义的变量声明提前，先暂时赋值为<code>undefined</code></li>
<li><strong>执行</strong></li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func() // 弹出提示</span><br><span class="line">alert(iNum) // undefined</span><br><span class="line">alert(abc) // 出错</span><br><span class="line">function func() &#123;</span><br><span class="line">    alert(&quot;这个是函数&quot;)</span><br><span class="line">&#125;</span><br><span class="line">var iNum = 1</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul>
<li>函数可以没有名字，比如直接为某些事件赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">	var sDate = new Date()</span><br><span class="line">	console.log(sDate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="封闭函数"><a href="#封闭函数" class="headerlink" title="封闭函数"></a>封闭函数</h4><ul>
<li>封闭函数常用来创建一个开始就执行而不用命名的函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    alert(&quot;你好&quot;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以在函数定义前加上”<code>~</code>“和”<code>!</code>“等符号来定义匿名函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!function()&#123;</span><br><span class="line">    alert(&quot;你好&quot;);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<ul>
<li>封闭函数可以创建一个独立的空间，在封闭函数内定义的变量不会影响外部同名的函数和变量，可以避免命名冲突</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">!function()&#123;</span><br><span class="line">	var x = &quot;这是同名变量&quot;;</span><br><span class="line">    alert(x);</span><br><span class="line">&#125;</span><br><span class="line">alert(x);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当页面上引入多个<code>js</code>文件时，用这种办法比较安全</p>
</blockquote>
<hr>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">示例</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+</code></td>
<td align="left">加</td>
<td align="left"><code>x=y+2</code></td>
<td align="left"><code>x=7</code></td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">减</td>
<td align="left"><code>x=y-2</code></td>
<td align="left"><code>x=3</code></td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td align="left">乘</td>
<td align="left"><code>x=y*2</code></td>
<td align="left"><code>x=10</code></td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left">除</td>
<td align="left"><code>x=y/2</code></td>
<td align="left"><code>x=2.5</code></td>
</tr>
<tr>
<td align="left"><code>%</code></td>
<td align="left">取余</td>
<td align="left"><code>x=y%2</code></td>
<td align="left"><code>x=1</code></td>
</tr>
<tr>
<td align="left"><code>++</code></td>
<td align="left">累加</td>
<td align="left"><code>x=++y</code></td>
<td align="left"><code>x=6</code></td>
</tr>
<tr>
<td align="left"><code>--</code></td>
<td align="left">递减</td>
<td align="left"><code>x=--y</code></td>
<td align="left"><code>x=4</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">例子</th>
<th align="left">等价于</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>=</code></td>
<td align="left"><code>x=y</code></td>
<td align="left"></td>
<td align="left"><code>x=5</code></td>
</tr>
<tr>
<td align="left"><code>+=</code></td>
<td align="left"><code>x+=y</code></td>
<td align="left"><code>x=x+y</code></td>
<td align="left"><code>x=15</code></td>
</tr>
<tr>
<td align="left"><code>-=</code></td>
<td align="left"><code>x-=y</code></td>
<td align="left"><code>x=x-y</code></td>
<td align="left"><code>x=5</code></td>
</tr>
<tr>
<td align="left"><code>*=</code></td>
<td align="left"><code>x*=y</code></td>
<td align="left"><code>x=x*y</code></td>
<td align="left"><code>x=50</code></td>
</tr>
<tr>
<td align="left"><code>/=</code></td>
<td align="left"><code>x/=y</code></td>
<td align="left"><code>x=x/y</code></td>
<td align="left"><code>x=2</code></td>
</tr>
<tr>
<td align="left"><code>%=</code></td>
<td align="left"><code>x%=y</code></td>
<td align="left"><code>x=x%y</code></td>
<td align="left"><code>x=0</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>注意</strong>：<strong>数字与字符串相加，结果将成为字符串</strong></li>
</ul>
<hr>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>==</code></td>
<td align="left">等于</td>
<td align="left"><code>x==8</code>为<code>false</code></td>
</tr>
<tr>
<td align="left"><code>===</code></td>
<td align="left">全等（值和类型）</td>
<td align="left"><code>x===5</code>为<code>true</code>；<code>x===&quot;5&quot;</code>为<code>false</code></td>
</tr>
<tr>
<td align="left"><code>!=</code></td>
<td align="left">不等于</td>
<td align="left"><code>x!=8</code>为<code>true</code></td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">大于</td>
<td align="left"><code>x&gt;8</code>为<code>false</code></td>
</tr>
<tr>
<td align="left"><code>&lt;</code></td>
<td align="left">小于</td>
<td align="left"><code>x&lt;8</code>为<code>true</code></td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td align="left">大于或等于</td>
<td align="left"><code>x&gt;=8</code>为<code>false</code></td>
</tr>
<tr>
<td align="left"><code>&lt;=</code></td>
<td align="left">小于或等于</td>
<td align="left"><code>x&lt;=8</code>为<code>true</code></td>
</tr>
</tbody></table>
<ul>
<li>比较运算符常在条件语句中进行使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;张三&quot;;</span><br><span class="line"> 	if (name==&quot;张三&quot;) &#123;</span><br><span class="line"> 		document.write(&quot;这个人是张三&quot;)</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&amp;&amp;</code></td>
<td align="left"><code>and</code></td>
<td align="left"><code>(x &lt; 10 &amp;&amp; y &gt; 1)</code> 为 <code>true</code></td>
</tr>
<tr>
<td align="left">`</td>
<td align="left"></td>
<td align="left">`</td>
</tr>
<tr>
<td align="left"><code>!</code></td>
<td align="left"><code>not</code></td>
<td align="left"><code>!(x==y)</code> 为 <code>true</code></td>
</tr>
</tbody></table>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var NumCheck = 0; </span><br><span class="line">var Dis = (NumCheck==0) ? &quot;是数字0&quot;:&quot;不是数字0&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果变量<code>NumCheck</code>是<code>0</code>，则<code>Dis</code>的值为：”是数字<code>0</code>“；反之为：”不是数字<code>0</code>“</li>
</ul>
<hr>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul>
<li>条件语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var iNum = 0;</span><br><span class="line">if (iNum==0)&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;else if (iNum==1) &#123;</span><br><span class="line">   	条件细分...;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	不满足以上条件均到这里;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>switch</code>语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var day = new Date().getDay();</span><br><span class="line">// 星期日:0  范围:0~6</span><br><span class="line">switch(day)&#123;</span><br><span class="line">	case 0:</span><br><span class="line">		alert(&quot;今天是星期二&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case 1:</span><br><span class="line">		...</span><br><span class="line">		break;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>工作原理</strong>：首先设置表达式<code>n</code>（通常是一个变量）；随后表达式的值会与结构中的每个<code>case</code>的值做比较。如果存在匹配，则与该<code>case</code>关联的代码块会被执行。请使用<em>break</em>来阻止代码自动地向下一个<code>case</code>运行</li>
</ul>
<hr>
<h3 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h3><ul>
<li><strong>语法</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i = 0; i &lt; len; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// for(起点数据; 判断条件; 数据递增或递减)&#123;&#125;</span><br><span class="line">var i = 0;</span><br><span class="line">for( ;i &lt; 10; i++)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">// 如果循环起始值已经被设置，可以在开头省略</span><br><span class="line">for(var i = 0; ; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (i==5)&#123;</span><br><span class="line">        ...</span><br><span class="line">        break; //终止循环</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 当没有第二个语句时，必须在循环内提供break，否则循环则无法停下来，可能令浏览器崩溃</span><br><span class="line">for(var i = 0; i &lt; 10; )&#123;</span><br><span class="line">   	console.log(i);</span><br><span class="line">    i += 2;</span><br><span class="line">&#125;</span><br><span class="line">// 如果没有提供第三个语句，可以在for循环中进行编写数值的变化</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for/in</code>语句循环遍历对象的属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (x in object)&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// 字符串：x 取下标</span><br><span class="line">// 数组：x 取下标</span><br><span class="line">// 对象：x 取key</span><br><span class="line">var x = &quot;abcdef&quot;  // 0,1,2,3,4,5</span><br><span class="line">var y = [1,2,3,4,&quot;5&quot;] // 0,1,2,3,4</span><br><span class="line">var z = &#123; //  name,age,gender</span><br><span class="line">    name:&quot;张三&quot;,</span><br><span class="line">    age:16,</span><br><span class="line">    gender:&quot;male&quot;,</span><br><span class="line">&#125;</span><br><span class="line">for (obj in z)&#123;</span><br><span class="line">    console.log(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h3><ul>
<li>语法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (条件)&#123;</span><br><span class="line">    执行代码;</span><br><span class="line">&#125;</span><br><span class="line">var x = &quot;abcdef&quot;;</span><br><span class="line">var i = 0;</span><br><span class="line">while (x[i])&#123;</span><br><span class="line">    console.log(x[i]);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">// 下表超出范围时不会报错，返回undefined</span><br></pre></td></tr></table></figure>

<ul>
<li><code>do/while</code>循环：<code>do/while</code>循环是<code>while</code>循环的变体</li>
</ul>
<blockquote>
<p>该循环首先会执行一次循环代码块，然后检查循环条件是否为真</p>
<p>如果条件为真，就会重复这个循环</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	循环执行代码</span><br><span class="line">&#125;while (条件);</span><br><span class="line">var i = 3;</span><br><span class="line">do&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">    i--;</span><br><span class="line">&#125;while (i &gt; 5);</span><br><span class="line">// do/while循环至少会执行一次</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="获取页面元素"><a href="#获取页面元素" class="headerlink" title="获取页面元素"></a>获取页面元素</h3><ul>
<li>通过页面元素<code>ID</code>值进行获取：<code>document.getElementById(&#39;&#39;)</code><ul>
<li>获取到的是一个<code>HTML</code>对象，可以赋值给一个变量</li>
</ul>
</li>
<li><strong>注意</strong>：获取对应元素时，首先要确定页面已经生成所需元素</li>
</ul>
<blockquote>
<p>通常我们将<code>javascript</code>代码写到页面最下面</p>
<p>或通过使用<code>windows.onload()</code>事件判断是否已经生成页面</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p id=&quot;p&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		function func()&#123;</span><br><span class="line">			var sP = document.getElementById(&apos;p&apos;);</span><br><span class="line">			console.log(sP);</span><br><span class="line">		&#125;</span><br><span class="line">		func()</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-- 获取到的内容: &lt;p id=&quot;p&quot;&gt;这是一段待获取的文字&lt;/p&gt; --&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p id=&quot;p&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		window.onload = function()&#123;</span><br><span class="line">			var sP = document.getElementById(&apos;p&apos;);</span><br><span class="line">			console.log(sP);</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-- 获取到的内容: &lt;p id=&quot;p&quot;&gt;这是一段待获取的文字&lt;/p&gt; --&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="操作页面元素"><a href="#操作页面元素" class="headerlink" title="操作页面元素"></a>操作页面元素</h3><ul>
<li>可以通过<code>id</code>方式获取到对应页面内的元素，就可以对元素的属性进行操作，包括对属性的读和写</li>
<li>读取元素属性：元素<code>.</code>属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;aaa&quot; style=&quot;color: red;&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var oP = document.getElementById(&apos;aaa&apos;);</span><br><span class="line">    console.log(oP)</span><br><span class="line">    console.log(oP.id);</span><br><span class="line">    console.log(oP.style);</span><br><span class="line">    console.log(oP.style.color);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改元素属性：元素.属性 =<code>xxx</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;aaa&quot; style=&quot;color: red;&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">&lt;button onclick=&quot;blue_font()&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function blue_font()&#123;</span><br><span class="line">        var oP = document.getElementById(&apos;aaa&apos;);</span><br><span class="line">        oP.style.color = &quot;blue&quot;;</span><br><span class="line">        // 修改字体样式属性中的字体颜色为蓝色</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p id=&quot;aaa&quot; style=&quot;color: red;&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">&lt;button id=&quot;color_button&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    color_button.onclick = function()&#123;</span><br><span class="line">        var oP = document.getElementById(&apos;aaa&apos;);</span><br><span class="line">        oP.style.color = &quot;blue&quot;;</span><br><span class="line">        // 修改字体样式属性中的字体颜色为蓝色</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以获取到对应按钮元素后在绑定函数到它</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;aaa&quot; style=&quot;color: red;&quot;&gt;这是一段待获取的文字&lt;/p&gt;</span><br><span class="line">&lt;button id=&quot;Button&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var oButton = document.getElementById(&apos;Button&apos;);</span><br><span class="line">    oButton.onclick = function()&#123;</span><br><span class="line">        var oP = document.getElementById(&apos;aaa&apos;);</span><br><span class="line">        oP.style.color = &quot;blue&quot;;</span><br><span class="line">        // 修改字体样式属性中的字体颜色为蓝色</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取或写入标签包裹的内容（读取或修改标签文本内容）：<code>innerHTML</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a id=&quot;a&quot; href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;</span><br><span class="line">&lt;button onclick=&quot;urlChange()&quot;&gt;变搜狗&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function urlChange()&#123;</span><br><span class="line">        var oA = document.getElementById(&apos;a&apos;);</span><br><span class="line">        oA.href = &quot;https://www.sougou.com&quot;;</span><br><span class="line">        console.log(oA.innerHTML); // 获取标签文本内容</span><br><span class="line">        oA.innerHTML = &quot;搜狗&quot;; //修改标签文本内容</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="JS事件及属性"><a href="#JS事件及属性" class="headerlink" title="JS事件及属性"></a>JS事件及属性</h3><ul>
<li>常见事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 用户点击鼠标</span><br><span class="line">- 网页已加载</span><br><span class="line">- 图像已加载</span><br><span class="line">- 鼠标移动某个元素上</span><br><span class="line">- 输入字段被改变时</span><br><span class="line">- 提交表单时</span><br><span class="line">- 用户触发某些按键时</span><br></pre></td></tr></table></figure>

<ul>
<li><code>onclick</code>事件：用户点击鼠标</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p onclick=&quot;TextChange(this)&quot;&gt;这是文本&lt;/p&gt;</span><br><span class="line">&lt;!-- this 代表当前所处的元素 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function TextChange(id)&#123;</span><br><span class="line">        id.innerHTML = &quot;文本修改&quot;//可以直接通过传来的参数进行页面元素的读取及修改</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p id=&quot;p&quot;&gt;这是文本&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var oP = document.getElementById(&quot;p&quot;);</span><br><span class="line">    oP.onclick = function()&#123;</span><br><span class="line">        oP.innerHTML = &quot;文本修改&quot;//可以直接通过传来的参数进行页面元素的读取及修改</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>onmouseover</code>事件：鼠标移入</li>
<li><code>onmouseout</code>事件：鼠标移出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;aaa&quot;&gt;请把鼠标移动过来&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var oP = document.getElementById(&quot;aaa&quot;);</span><br><span class="line">    oP.onmouseover = function()&#123;</span><br><span class="line">        oP.style.color = &quot;green&quot;;//可以直接通过传来的参数进行页面元素的读取及修改</span><br><span class="line">    &#125;</span><br><span class="line">    oP.onmouseout = function()&#123;</span><br><span class="line">        oP.style.color = &quot;red&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="JS高级"><a href="#JS高级" class="headerlink" title="JS高级"></a>JS高级</h2><h3 id="字符串及操作方法"><a href="#字符串及操作方法" class="headerlink" title="字符串及操作方法"></a>字符串及操作方法</h3><ul>
<li>字符串合并：<code>+</code></li>
<li>数字字符串变整数：<code>parseInt()</code></li>
<li>数字字符串变浮点数：<code>parseFloat()</code></li>
<li>字符串按分隔符切分：<code>split(&quot;*&quot;)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;a*b*c*d&quot;</span><br><span class="line">alert(x.split(&quot;*&quot;)) // a,b,c,d</span><br><span class="line">console.log(x.split(&quot;*&quot;)) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li>查找字符串是否含有某字符，找到返回索引，找不到返回-1：<code>String.indexOf()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;abcdefag&quot;</span><br><span class="line">var res = x.indexOf(&quot;z&quot;)</span><br><span class="line">alert(res)</span><br></pre></td></tr></table></figure>

<ul>
<li>截取字符串：<code>String.substring(start, end)</code>，不包含end索引位置数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;abcdefag&quot;</span><br><span class="line">alert(x.substring(2)) // cdefag</span><br><span class="line">alert(x.substring(2,4)) // cd</span><br><span class="line">alert(x.substring()) // abcdefag</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串反转：通过结合数组的<code>reverse()</code>函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = &quot;abcd&quot;;</span><br><span class="line">console.log(x.split(&quot;&quot;).reverse().join(&quot;&quot;)) //dcba</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="数组及操作方法"><a href="#数组及操作方法" class="headerlink" title="数组及操作方法"></a>数组及操作方法</h3><ul>
<li>定义数组的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = new Array(1,2,3);</span><br><span class="line">var aList = new Array();</span><br><span class="line">aList[0] = &quot;a&quot;;</span><br><span class="line">aList[1] = &quot;b&quot;;</span><br><span class="line">var aList = [1,2,3,4,&quot;a&quot;];</span><br></pre></td></tr></table></figure>

<ul>
<li>获取数组的长度：<code>Array.length()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = new Array(1,2,3);</span><br><span class="line">console.log(aList.length) // 3</span><br></pre></td></tr></table></figure>

<ul>
<li>将数组成员通过指定拼接符合并成一个字符串：<code>Array.join(&quot;*&quot;)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,3,4,5]</span><br><span class="line">console.log(aList.join(&quot;*&quot;)) // 1*2*3*4*5</span><br></pre></td></tr></table></figure>

<ul>
<li>向数组的<strong>最后</strong>增加或删除成员：<code>Array.pop()</code>、<code>Array.push()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,3,4,5]</span><br><span class="line">var opa = aList.pop() // opa: 5</span><br><span class="line">console.log(opa) // 5</span><br><span class="line">console.log(aList) // [1, 2, 3, 4]</span><br><span class="line">aList.push(&quot;a&quot;)</span><br><span class="line">console.log(aList) // [1, 2, 3, 4, &quot;a&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li>将数组反转：<code>Array.reverse()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,3,4,5];</span><br><span class="line">aList.reverse();</span><br><span class="line">console.log(aList); //[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>

<ul>
<li>返回数组中元素第一次出现的索引值：<code>Array.indexOf(chr)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,3,4,5];</span><br><span class="line">console.log(aList.indexOf(3)) // 2</span><br></pre></td></tr></table></figure>

<ul>
<li>在数组中增加或删除成员，并返回被删除的：<code>Array.splice(index, howmany, items...)</code></li>
</ul>
<blockquote>
<p>从<code>index</code>位置开始，给定的<code>hwomany</code>个数的值，并用后面的<code>items</code>替换这些被<strong>删除</strong>的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,&quot;a&quot;,4,5]</span><br><span class="line">aList.splice(2,1,&quot;b&quot;,&quot;c&quot;)</span><br><span class="line">console.log(aList) // [1, 2, &quot;b&quot;, &quot;c&quot;, 4, 5]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><blockquote>
<p>数组的成员包含数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aList = [1,2,3,[&quot;a&quot;,&quot;b&quot;]]</span><br><span class="line">console.log(aList[-1][0]) // 出错 undefined</span><br><span class="line">console.log(aList[3][0]) // a</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li>作用：定时调用函数、制作动画</li>
</ul>
<hr>
<h4 id="反复执行定时器"><a href="#反复执行定时器" class="headerlink" title="反复执行定时器"></a>反复执行定时器</h4><ul>
<li><code>setInterval(code, millisec)</code>：反复执行的定时器</li>
<li><code>code</code>: 必须参数，要调用的函数或要执行的代码串<ul>
<li><code>millisec</code>: 必须参数，执行<code>code</code>任务所需要的事件间隔，以毫秒计</li>
</ul>
</li>
<li><code>clearInterval(setInterval_obj)</code>：<strong>关闭</strong>反复执行的定时器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--跑马灯效果--&gt;</span><br><span class="line">&lt;h3 id=&quot;h3&quot;&gt;abcdefg&lt;/h3&gt;</span><br><span class="line">&lt;button id=&quot;start_button&quot;&gt;开始&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;stop_button&quot;&gt;停止&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    start_button.onclick = function()&#123; // 开启定时事件</span><br><span class="line">    	var sT = setInterval(loop,1000);</span><br><span class="line">    	window.sT = sT; // 声明此sT定时事件为全局变量</span><br><span class="line">	&#125;</span><br><span class="line">    stop_button.onclick = function()&#123; // 关闭定时事件</span><br><span class="line">        clearInterval(sT)</span><br><span class="line">    &#125;</span><br><span class="line">    function loop()&#123;</span><br><span class="line">        var Opstr = document.getElementById(&apos;h3&apos;);</span><br><span class="line">        Opstr.innerHTML = Opstr.innerHTML.substring(1) + Opstr.innerHTML[0]</span><br><span class="line">        console.log(Opstr.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="等待执行定时器"><a href="#等待执行定时器" class="headerlink" title="等待执行定时器"></a>等待执行定时器</h4><ul>
<li><p><code>setTimeout(code, millisec)</code>：定义只执行一次的等待定时器</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code</span><br></pre></td></tr></table></figure>

<p>: 必须参数，要调用的函数或要执行的代码串</p>
<ul>
<li><code>millisec</code>: 必须参数，执行<code>code</code>任务所需要的事件间隔，以毫秒计</li>
</ul>
</li>
<li><p><code>clearTimeout(setTimeout_obj)</code>：关闭只执行一次的等待计时器</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h3 id=&quot;h3&quot;&gt;我是一个内容&lt;/h3&gt;</span><br><span class="line">&lt;button id=&quot;start_button&quot;&gt;让上面的内容消失&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    start_button.onclick = function()&#123;</span><br><span class="line">        var st = setTimeout(clear,1000)</span><br><span class="line">        window.st = st;</span><br><span class="line">    &#125;</span><br><span class="line">    function clear()&#123;</span><br><span class="line">        var oH3 = document.getElementById(&apos;h3&apos;);</span><br><span class="line">        oH3.innerHTML = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
</search>
